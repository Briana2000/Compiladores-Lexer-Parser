package ParserLexer;
import java_cup.runtime.*;

// Aquí va la gramática BNF que hicimos solo que se pone con ::= en vez de la flecha 
// También se declaran los terminales y los no terminales por medio de los símbolos y las producciones

parser code {:
    Lexer lex;

    @SuppressWarnings("deprecation")
    public parser(Lexer lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
:}

init with {: :}; // define como inicializar el parser
scan with {: return lex.next_token(); :}; // define como conectarse con el scanner


////// Terminales ///////

// Tipos de datos
terminal INT, CHAR, STRING, FLOAT, BOOLEAN;
// Operadores Logicos
terminal TRUE, FALSE;
// Funciones
terminal RETURN, MAIN;
// Estrucutras de control
terminal IF, ELIF, ELSE, DO, WHILE, FOR, BREAK;
// Entrada y salida
terminal READ_INT, READ_FLOAT, PRINT_INT, PRINT_FLOAT, PRINT_STRING;

// Operadores
terminal PLUS, MINUS, TIMES, DIV;
terminal POWER, MODULE, PLUS_UN, MINUS_UN;
terminal AND, OR, NOT, EXCLAMACION;
terminal MAYOR_QUE, MAYOR_IGUAL, MENOR_QUE, MENOR_IGUAL, DEQUIV, DIF;

// Miscelaneos
terminal EQUIV, LPARENT, RPARENT, LPARENT_CUAD, RPARENT_CUAD;
terminal INIBLOQUE, FINBLOQUE, COMA, FINEXP;

// Literales
terminal ENTERO, DECIMAL, CADENA, ENTERO_POSITIVO, CARACTER;

// Identificadores
terminal ID;


////// NO Terminales ///////  
non terminal nuevoLenguaje, tipoVar;
non terminal funciones, funcion, funcionMain, tipoRet, bloque;
non terminal parametros, parametro, sentencias, sentencia;
non terminal creaVar, asignacion, creaAsignaVar;
non terminal llamaFunc, parametrosLlamada, parametroLlamada, returnFunc;
non terminal literal;
non terminal input, leeInt, leeFloat, output, escribeInt, escribeFloat, escribeString;
non terminal operacion, operacionAritmetica, operadorArit, operandoArit;
non terminal operacionLogica, operadorLog, operandoLog, negacion;
non terminal operacionRelacional, operadorRel;
non terminal control, ciclo, condicional, condIf, condsElif, condElif, condElse;
non terminal cicloDoWhile, cicloFor, bloqueCiclo, sentenciasCiclo, sentenciaCiclo, breakCiclo;
non terminal arregloSinTam, asignaElementoArreglo, expArreglo, cantidadArreglo; 
non terminal asignaArreglo, asignaArreglos, tipoArreglo, creaAsignaArreglo, creaArreglo;

//non terminal nuevoLenguaje, funciones, tipoVar, creaVar, arregloConTam, parteIzAsig;
//non terminal nuevoLenguaje, funciones, tipoVar, creaVar, arregloConTam, parteIzAsig;
//non terminal nuevoLenguaje, funciones, tipoVar, creaVar, arregloConTam, parteIzAsig;

////// precedencia ///////
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left POWER, MODULE;

precedence left AND, OR;
precedence left NOT, EXCLAMACION;
precedence nonassoc LPARENT, RPARENT;

////// producción de inicio ///////

start with nuevoLenguaje;

////// producciones de la gramática ///////

nuevoLenguaje ::=       funcionMain {:System.out.println("Funcion main");:}
                    |   funcionMain funciones {:System.out.println("Funciones y funcion main");:};


funcionMain ::= INT MAIN LPARENT RPARENT INIBLOQUE bloque FINBLOQUE;

funciones ::=       funcion {: System.out.println("funcion");:}
                |   funciones funcion;

funcion ::=         tipoRet ID LPARENT parametros RPARENT INIBLOQUE bloque FINBLOQUE
                |   tipoRet ID LPARENT RPARENT INIBLOQUE bloque FINBLOQUE;


tipoRet ::=     INT:n {: System.out.println(n + " de tipo ret");:} 
            |   FLOAT
            |   BOOLEAN;

parametros ::=      parametro
                |   parametro COMA parametros;

parametro ::= tipoVar ID;
// faltan algunos en parametro

// creación de variables 
tipoVar ::=   INT:n {: System.out.println(n);:}
            | FLOAT
            | CHAR
            | STRING
            | BOOLEAN;

bloque ::= sentencias;

sentencias ::=      sentencia
                |   sentencia sentencias;

sentencia ::=       creaVar {:System.out.println("Sentencia Crea variable");:}
                |   asignacion {:System.out.println("Sentencia Asignacion");:}
                |   llamaFunc   {:System.out.println("Sentencia Llamada a funcion");:}
                |   output    {:System.out.println("Sentencia Salida");:}
                |   control {:System.out.println("Sentencia Control");:}
                |   returnFunc {:System.out.println("Sentencia Return");:}
                |   creaArreglo {:System.out.println("Sentencia Creacion de arreglo");:}
                |   asignaArreglo {:System.out.println("Sentencia Asignacion de arreglo");:};

// faltan los arreglos
creaVar ::= tipoVar ID:n FINEXP {:System.out.println("Variable: "+ n);:};

asignacion ::=      creaAsignaVar FINEXP
                |   ID:n EQUIV:n2 literal:n3 FINEXP {:System.out.println("Asignacion: "+ n + " = " + n3);:}
                |   ID:n EQUIV:n2 llamaFunc:n3 FINEXP {:System.out.println("Asignacion: "+ n + " = " + n3);:}
                |   ID:n EQUIV:n2 input:n3 FINEXP {:System.out.println("Asignacion: "+ n + " = " + n3);:};

creaAsignaVar ::=   tipoVar ID EQUIV literal
                |   tipoVar ID EQUIV llamaFunc
                |   tipoVar ID EQUIV input;

                //|   tipoVar ID EQUIV arreglo FINEXP
                //|   tipoVar ID EQUIV arregloConTam FINEXP

literal ::=     operacion
    // operacion contiene operando aritmetico que a su vez contiene entero, decimal, id
            |   CADENA:n {:System.out.println("Cadena: "+ n);:}
            |   CARACTER:n {:System.out.println("Caracter: "+ n);:};


operacion ::=       operacionLogica;

operacionAritmetica ::=     operandoArit
                        |   operacionAritmetica operadorArit operandoArit {:System.out.println("Operacion Arit +-*/ Arit");:}
                        |   LPARENT operacionAritmetica RPARENT {:System.out.println("Operacion Arit (Arit)");:};

operadorArit ::=    PLUS
                |   MINUS
                |   TIMES
                |   DIV
                |   POWER
                |   MODULE;

operandoArit ::=        ENTERO:n {:System.out.println("Entero: "+ n);:}
                    |   DECIMAL
                    |   ID:n {:System.out.println("Entero: "+ n);:};

operacionRelacional ::=     operacionAritmetica operadorRel operacionAritmetica:e2 {:System.out.println( "Operacion Arit >=<== Arit");:};

operadorRel ::=     MAYOR_QUE {:System.out.println(">");:}
                |   MAYOR_IGUAL {:System.out.println(">=");:}
                |   MENOR_QUE {:System.out.println("<");:}
                |   MENOR_IGUAL {:System.out.println("<=");:}
                |   DEQUIV  {:System.out.println("==");:}
                |   DIF {:System.out.println("!=");:};

operacionLogica ::=     operandoLog
                    |   operacionRelacional {:System.out.println("Operacion Rel");:}
                    |   operacionAritmetica {:System.out.println("Operacion Arit");:}
                    |   operacionLogica operadorLog operacionLogica {:System.out.println("Operacion Logica");:}
                    |   LPARENT operacionLogica RPARENT  {:System.out.println("Parentesis");:} %prec LPARENT
                    |   negacion operacionLogica; 

operandoLog ::=     TRUE
                |   FALSE;


operadorLog ::=     AND
                |   OR;


negacion ::=        NOT
                |   EXCLAMACION;


llamaFunc ::=       ID LPARENT parametrosLlamada RPARENT FINEXP
                |   ID LPARENT RPARENT FINEXP;


parametrosLlamada ::=       parametroLlamada
                        |   parametroLlamada COMA parametrosLlamada;

parametroLlamada ::=    literal;
////// I/O ///////

// Input
input ::=       leeInt 
            |   leeFloat;
leeInt ::= READ_INT LPARENT RPARENT FINEXP;
leeFloat ::= READ_FLOAT LPARENT RPARENT FINEXP;

// Output
output ::=      escribeInt 
            |   escribeFloat
            |   escribeString;
        
escribeInt ::=      PRINT_INT LPARENT ID RPARENT FINEXP
                |   PRINT_INT LPARENT ENTERO RPARENT FINEXP;


escribeFloat ::=    PRINT_FLOAT LPARENT ID RPARENT FINEXP
                |   PRINT_FLOAT LPARENT DECIMAL RPARENT FINEXP;

escribeString ::= PRINT_STRING LPARENT ID RPARENT FINEXP
                | PRINT_STRING LPARENT CADENA RPARENT FINEXP;

////// Control de flujo ///////

control ::= condicional | ciclo;

condicional ::= condIf condsElif condElse
            |   condIf condsElif
            |   condIf condElse
            |   condIf;

condIf ::= IF LPARENT operacionLogica RPARENT INIBLOQUE bloque FINBLOQUE;

condsElif ::= condElif
            | condElif condsElif;

condElif ::= ELIF LPARENT operacionLogica RPARENT INIBLOQUE bloque FINBLOQUE;

condElse ::= ELSE INIBLOQUE bloque FINBLOQUE;

ciclo ::= cicloDoWhile
        | cicloFor;


cicloDoWhile ::=    DO INIBLOQUE bloqueCiclo FINBLOQUE WHILE LPARENT operacionLogica RPARENT FINEXP;

cicloFor ::= FOR LPARENT creaAsignaVar FINEXP operacionLogica FINEXP asignacion RPARENT INIBLOQUE bloqueCiclo FINBLOQUE;

bloqueCiclo ::= sentenciasCiclo;

sentenciasCiclo ::=     sentenciaCiclo
                    |   sentenciaCiclo sentenciasCiclo;

sentenciaCiclo ::=      sentencia
                    |   breakCiclo;

breakCiclo ::= BREAK FINEXP;
returnFunc ::= RETURN literal FINEXP;


// Arreglos

asignaArreglo ::=       asignaElementoArreglo FINEXP
                    |   creaAsignaArreglo FINEXP;

arregloSinTam ::=       tipoVar ID LPARENT_CUAD RPARENT_CUAD;

creaArreglo ::=     tipoArreglo FINEXP;

creaAsignaArreglo ::=       tipoArreglo EQUIV INIBLOQUE asignaArreglos FINBLOQUE
                        |   arregloSinTam EQUIV INIBLOQUE asignaArreglos FINBLOQUE;

tipoArreglo ::=     tipoVar expArreglo;

asignaArreglos ::=       asignaArreglo
                    |   asignaArreglo COMA asignaArreglos;

asignaArreglo ::=       CARACTER
                    |   ENTERO
                    |   ID;

cantidadArreglo ::=     ENTERO
                    |   ID;

asignaElementoArreglo ::=   expArreglo EQUIV ENTERO
                        |   expArreglo EQUIV CARACTER
                        |   expArreglo EQUIV ID;

expArreglo  ::=     ID LPARENT_CUAD cantidadArreglo RPARENT_CUAD;

