package ParserLexer;
import java_cup.runtime.*;
import java.util.HashMap;
import java.util.ArrayList;

// Aquí va la gramática BNF que hicimos solo que se pone con ::= en vez de la flecha 
// También se declaran los terminales y los no terminales por medio de los símbolos y las producciones

// CODIGO JAVA 

action code {:

    
:}

parser code {:
    Lexer lex;
    Symbol token;
    Boolean errores = false;

    /* Constructor del parser, recibe como parámetro el lexer que se va a utilizar 
        Entradas: Lexer lex
        Salidas: Ninguna
        Restricciones: Ninguna
    */

    @SuppressWarnings("deprecation")
    public parser(Lexer lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
    
    /* Método que se encarga de retornar el valor booleao de errores. Indicando si hubo errores o no
        Entradas: Ninguna
        Salidas: errores
        Restricciones: Ninguna
    */
    public boolean getErrores(){
        return errores;
    }

    private HashMap<String, ArrayList<String>> listaTablaSimbolos = new HashMap<String, ArrayList<String>>();
    String currentHash;

    /* Método que se encarga de imprimir la tabla de símbolos
        Entradas: Ninguna
        Salidas: Ninguna
        Restricciones: Ninguna
    */
    private void imprimirTablaSimbolos(){
        for(String key: listaTablaSimbolos.keySet()){
            System.out.println("-------------------------");
            System.out.println("");
            System.out.println("Tabla de símbolos: "+key);
            System.out.println("Valores: ");
            for(String item: listaTablaSimbolos.get(key)){
                System.out.println(item);
            }

            System.out.println("");
        }

    }

    /*
        Método que se encarga de retornar la tabla de símbolos
        Entradas: Ninguna
        Salidas: tabla de símbolos
        Restricciones: Ninguna
    */
    public HashMap<String, ArrayList<String>> getTablaSimbolos(){
        return listaTablaSimbolos;
    }

    /* Método que se encarga de imprimir en consola el error sintáctico
        Entradas: String error. Error que se va a imprimir
        Salidas: Ninguna. Imprime en consola el error
        Restricciones: Ninguna
    */
    private void manejoError(String error, String tipoError){
        errores = true;
        int linea = lex.getLine();
        int columna = lex.getColumn();
        System.out.println("Error "+tipoError+": "+ error +" (en la linea: " + linea + " y columna: " + columna+")");
        System.out.println("Se continua con el análisis "+tipoError);
    } 

    /* Método que se encarga de buscar en la tabla de símbolos actual un ID y devolver su tipo.
        Entradas: lista: lista de elementos de la tabla de símbolos actual, idBuscado: ID que se requiere buscar y queBusca: si busca el ID de una variable o de una función. 
        Salidas: String o null
        Restricciones: Ninguna
    */
     public String buscarID_o_tipoID(ArrayList<String> tablaSimbolos, String idBuscado, String queBusca) {

        if(queBusca.equals("id")){
            // Recorre los elementos del ArrayList
            for (String elemento : tablaSimbolos) {
                // Divide el elemento en ID y tipo
                String[] partes = elemento.split(": ");
                if (partes[0].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                    return partes[1]; // Se encontró el ID y se envía el tipo del ID
                }
                if (partes[0].equals("Parámetro: "+idBuscado)) { // Verifica si el ID coincide con el ID buscado
                    return partes[1]; // Se encontró el ID y se envía el tipo del ID
                }	
            }
            return null;
        }
        else if(queBusca.equals("funcion")){
            // Recorre los elementos del ArrayList
            for (String elemento : tablaSimbolos) {
                // Divide el elemento en ID y tipo
                String[] partes = elemento.split(":");
            
                if (partes[1].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                    return partes[2]; // Se encontró el ID de la función y se envía el tipo de la función
                }
            }
            return null;
        }
        return null;       
    }

:}

init with {: :}; // define como inicializar el parser
scan with {: return token = lex.next_token(); :}; // define como conectarse con el scanner


////// Terminales ///////

// Tipos de datos
terminal INT, CHAR, STRING, FLOAT, BOOLEAN;
// Operadores Logicos
terminal TRUE, FALSE;
// Funciones
terminal RETURN, MAIN;
// Estrucutras de control
terminal IF, ELIF, ELSE, DO, WHILE, FOR, BREAK;
// Entrada y salida
terminal READ_INT, READ_FLOAT, PRINT_INT, PRINT_FLOAT, PRINT_STRING;

// Operadores
terminal PLUS, MINUS, TIMES, DIV;
terminal POWER, MODULE, PLUS_UN, MINUS_UN;
terminal AND, OR, NOT, EXCLAMACION;
terminal MAYOR_QUE, MAYOR_IGUAL, MENOR_QUE, MENOR_IGUAL, DEQUIV, DIF;

// Miscelaneos
terminal EQUIV, LPARENT, RPARENT, LPARENT_CUAD, RPARENT_CUAD;
terminal INIBLOQUE, FINBLOQUE, COMA, FINEXP;

// Literales
terminal ENTERO, DECIMAL, CADENA, CARACTER;

// Identificadores
terminal ID;


////// NO Terminales ///////  
non terminal nuevoLenguaje, tipoVar;
non terminal funciones, funcion, funcionMain, tipoRet, iniFun, identifier, bloque;
non terminal parametros, parametro, sentencias, sentencia;
non terminal creaVar, asignacion, creaAsignaVar, usaVar;
non terminal llamaFunc, parametrosLlamada, parametroLlamada, returnFunc;
non terminal literal;
non terminal input, leeInt, leeFloat, output, escribeInt, escribeFloat, escribeString;
non terminal operacion, operacionAritmetica, operadorArit, operandoArit;
non terminal operacionLogica, operadorLog, operandoLog, negacion;
non terminal operacionRelacional, operadorRel;
non terminal control, ciclo, condicional, condIf, condsElif, condElif, condElse;
non terminal cicloDoWhile, cicloFor, bloqueCiclo, sentenciasCiclo, sentenciaCiclo, breakCiclo;
non terminal arregloSinTam, asignaElementoArreglo, expArreglo, cantidadArreglo; 
non terminal asignaArreglo, arregloValores, arregloValor, tipoArreglo, creaAsignaArreglo, creaArreglo;
non terminal tipoVarSubset;

//non terminal nuevoLenguaje, funciones, tipoVar, creaVar, arregloConTam, parteIzAsig;
//non terminal nuevoLenguaje, funciones, tipoVar, creaVar, arregloConTam, parteIzAsig;
//non terminal nuevoLenguaje, funciones, tipoVar, creaVar, arregloConTam, parteIzAsig;

////// precedencia ///////
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left POWER, MODULE;

precedence left AND, OR;
precedence left NOT, EXCLAMACION;
precedence left LPARENT, LPARENT_CUAD, RPARENT, RPARENT_CUAD;

////// producción de inicio ///////

start with nuevoLenguaje;

////// producciones de la gramática ///////

nuevoLenguaje ::=       funcionMain {: imprimirTablaSimbolos(); :}
                    |   funcionMain funciones {: imprimirTablaSimbolos(); :} ;


funcionMain ::= iniFun LPARENT RPARENT INIBLOQUE bloque FINBLOQUE 
                |   error {: manejoError("Error de creación de función main", "sintáctico"); :};

funciones ::=       funcion {: :}
                |   funciones funcion;

funcion ::=         iniFun LPARENT parametros RPARENT INIBLOQUE bloque FINBLOQUE 
                |   iniFun LPARENT RPARENT INIBLOQUE bloque FINBLOQUE
                |   iniFun LPARENT parametros RPARENT INIBLOQUE FINBLOQUE error {: manejoError("Funcion debe tener sentencias debido a que debe retornar un valor", "sintáctico"); :}
                |   iniFun LPARENT  RPARENT INIBLOQUE FINBLOQUE error {: manejoError("Funcion debe tener sentencias debido a que debe retornar un valor", "sintáctico"); :}
                |   error {: manejoError("Error de creación de función", "sintáctico"); :};

tipoRet ::=     INT {: RESULT = "int";:}
            |   FLOAT {: RESULT = "float";:}
            |   BOOLEAN {: RESULT = "boolean";:};

iniFun ::= tipoRet:tip identifier:id 
{:
           String tipoTabla;
           if(id.toString().equals("main")){
            tipoTabla = "tipo:main: "+tip.toString();
           }
           else{
            tipoTabla = "tipo:funcion: "+tip.toString();
           }
           ArrayList<String> listaSimbolos = new ArrayList<String>();
           currentHash = id.toString();
           listaSimbolos.add(tipoTabla);
           listaTablaSimbolos.put(currentHash, listaSimbolos);
           RESULT = tip.toString()+" "+id.toString();

:};

identifier ::=  MAIN {: RESULT = "main";:}
              | ID:id {: RESULT = id.toString();:} ;

parametros ::=      parametro
                |   parametro COMA parametros;

parametro ::= tipoVar:tip ID:id 
                {: listaTablaSimbolos.get(currentHash).add("Parámetro: "+id.toString()+": "+tip.toString());:} 
            | tipoVarSubset:tip ID:id
                {: listaTablaSimbolos.get(currentHash).add("Parámetro: "+id.toString()+": "+tip.toString());:} ; 

// creación de variables 
tipoVar ::=   FLOAT {: RESULT = "float";:}
            | STRING {: RESULT = "string";:}
            | BOOLEAN {: RESULT = "boolean";:} ;


tipoVarSubset ::=   INT {: RESULT = "int"; :}
                |   CHAR {: RESULT = "char"; :} ;

bloque ::= sentencias;

sentencias ::=      sentencia
                |   sentencia sentencias;

sentencia ::=       creaVar:cv FINEXP {:  
                        if(cv != null){
                            listaTablaSimbolos.get(currentHash).add(cv.toString()); 
                        }   
                    :}
                |   usaVar {: :}
                |   asignacion:asign {:
                        if(asign != null){
                            listaTablaSimbolos.get(currentHash).add(asign.toString());
                        }  
                    :}
                |   llamaFunc FINEXP   {::}
                |   output      {::}
                |   control     {::}
                |   returnFunc  {::}
                |   creaArreglo:creaArr 
                    {:
                      if(creaArr != null){
                        listaTablaSimbolos.get(currentHash).add(creaArr.toString());
                      }
                    :}
                |   asignaArreglo:asigArr 
                    {:
                        if(asigArr != null){
                            listaTablaSimbolos.get(currentHash).add(asigArr.toString());
                        }  
                    :} 
                |   error {: manejoError("Error de sentencia","sintáctico"); :};

usaVar ::=      ID FINEXP
            |   PLUS_UN ID:id FINEXP 
            {:  
                String tip = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id");
                if(tip != null){ // Análisis semántico
                    RESULT = id.toString()+": "+tip;
                }
                else{
                    manejoError("El ID: "+id+" no se ha declarado dentro de la función: "+currentHash, "semántico");
                    RESULT = null;
                } 
            :}
            |   MINUS_UN ID:id FINEXP
            {:  
                String tip = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id");
                if(tip != null){ // Análisis semántico
                    RESULT = id.toString()+": "+tip;
                }
                else{
                    manejoError("El ID: "+id+" no se ha declarado dentro de la función: "+currentHash, "semántico");
                    RESULT = null;
                } 
            :} ;

creaVar ::=     tipoVar:tip ID:id  
               {: if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){ // Análisis semántico
                    RESULT = id.toString()+": "+tip.toString();
                  }
                  else{
                    manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de la función: "+currentHash, "semántico");
                    RESULT = null;
                  }
                :}

            |   tipoVarSubset:tip ID:id  
                {: if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){ // Análisis semántico
                    RESULT = id.toString()+": "+tip.toString();
                  }
                  else{
                    manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de la función: "+currentHash, "semántico");
                    RESULT = null;
                  }
                :} ;

asignacion ::=      creaAsignaVar:cv FINEXP {: RESULT = cv ; :}
                |   ID:n EQUIV:n2 literal:n3 FINEXP {::}
                |   ID:n EQUIV:n2 input:n3 FINEXP {::};

creaAsignaVar ::=    creaVar:cv EQUIV literal:lit 
                     {: if(cv != null && lit != null){
                            String[] partes = cv.toString().split(": ");
                            if(!partes[1].equals(lit.toString())){  // Análisis semántico
                                System.out.println("++++++El tipo de la variable es: "+partes[1]);
                                System.out.println("++++++El tipo del literal es: "+lit.toString());
                                manejoError("El tipo del ID: "+partes[0].toString()+" no corresponde con los valores asignados", "semántico") ;
                            }
                        }
                        RESULT = cv;
                     :}
                  |  creaVar:cv EQUIV input {: RESULT = cv ; :} ; 
 
                //|   tipoVar ID EQUIV arreglo FINEXP
                //|   tipoVar ID EQUIV arregloConTam FINEXP

literal ::=     operacion:op {:RESULT = op ;:}// operacion contiene operando aritmetico que a su vez contiene entero, decimal, id
            |   CADENA {: RESULT = "string" ;:}
            |   CARACTER {:RESULT = "char" ;:}
            |   BOOLEAN {:RESULT = "boolean" ;:}
            |   error {: manejoError("Error de literal", "sintáctico"); :};

operacion ::=       operacionLogica:opLog {: RESULT = opLog; :} ;

operacionAritmetica ::=     operandoArit:opeArit {: RESULT = opeArit; :}
                        |   PLUS_UN operandoArit:opeArit {: RESULT = opeArit; :}
                        |   MINUS_UN operandoArit:opeArit {: RESULT = opeArit; :}
                        |   operacionAritmetica:operacion1 operadorArit operacionAritmetica:operacion2
                            {: if (operacion1 != null && operacion2 != null){
                                    if(operacion1.toString().equals(operacion2.toString())){
                                        RESULT = operacion1;
                                    }
                                    else if(!operacion1.toString().equals(operacion2.toString())){
                                        System.out.println("+++++++++El tipo de la operación 1 es: "+operacion1.toString());
                                        System.out.println("+++++++++El tipo de la operación 2 es: "+operacion2.toString());
                                        manejoError("Uno de los operandos de la operación aritmética no coincide con el tipo de la variable asignada", "semántico");
                                        RESULT = null;
                                    }
                                }
                                else{
                                    
                                    RESULT = null; 
                                }
                            :}
                        |   LPARENT operacionAritmetica:operacion RPARENT {: RESULT = operacion; :}                            
                        |   MINUS operacionAritmetica:operacion {: RESULT = operacion; :} ;

operadorArit ::=    PLUS 
                |   MINUS 
                |   TIMES 
                |   DIV 
                |   POWER 
                |   MODULE ;

operandoArit ::=        ENTERO:n {: RESULT = "int"; :}
                    |   DECIMAL:n {: RESULT = "float"; :}
                    |   ID:id 
                    {:  String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id");
                        if(tipo != null){
                            RESULT = tipo;
                        } 
                        else{
                            manejoError("El id: "+id+" no existe o no ha sido creado", "semántico");
                            RESULT = null;
                        } 
                    :}
                    |   llamaFunc //**************************************************************** FALTA ANALISIS SEMANTICO*********************************************************
                    |   expArreglo:id
                    {:  String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id");
                        if( tipo != null){
                            RESULT = tipo;
                        }
                        else{
                            manejoError("El id: "+id+" no existe o no ha sido creado", "semántico");
                            RESULT = null;
                        }
                        :} ;

operacionRelacional ::=     operacionAritmetica operadorRel operacionAritmetica:e2 {::};

operadorRel ::=     MAYOR_QUE {::}
                |   MAYOR_IGUAL {::}
                |   MENOR_QUE {::}
                |   MENOR_IGUAL {::}
                |   DEQUIV  {::}
                |   DIF {::};

operacionLogica ::=     operandoLog {: RESULT = "boolean"; :}
                    |   operacionRelacional {: RESULT = "boolean"; :}
                    |   operacionAritmetica:opArit {: RESULT = opArit; :}
                    |   operacionLogica operadorLog operacionLogica {: RESULT = "boolean"; :}
                    |   LPARENT operacionLogica:opLog RPARENT  {: RESULT = opLog; :} %prec LPARENT
                    |   negacion operacionLogica {: RESULT = "boolean"; :} ; 

operandoLog ::=     TRUE
                |   FALSE ;


operadorLog ::=     AND
                |   OR;

negacion ::=        NOT
                |   EXCLAMACION;


llamaFunc ::=       ID LPARENT parametrosLlamada RPARENT
                |   ID LPARENT RPARENT;


parametrosLlamada ::=       parametroLlamada
                        |   parametroLlamada COMA parametrosLlamada;

parametroLlamada ::=    literal;
////// I/O ///////

// Input
input ::=       leeInt 
            |   leeFloat;
leeInt ::= READ_INT LPARENT RPARENT FINEXP;
leeFloat ::= READ_FLOAT LPARENT RPARENT FINEXP;

// Output
output ::=      escribeInt 
            |   escribeFloat
            |   escribeString;
        
escribeInt ::=      PRINT_INT LPARENT ID RPARENT FINEXP
                |   PRINT_INT LPARENT ENTERO RPARENT FINEXP;


escribeFloat ::=    PRINT_FLOAT LPARENT ID RPARENT FINEXP
                |   PRINT_FLOAT LPARENT DECIMAL RPARENT FINEXP;

escribeString ::= PRINT_STRING LPARENT ID RPARENT FINEXP
                | PRINT_STRING LPARENT CADENA RPARENT FINEXP;

////// Control de flujo ///////

control ::= condicional | ciclo;

condicional ::= condIf condsElif condElse
            |   condIf condsElif
            |   condIf condElse
            |   condIf;

condIf ::= IF LPARENT operacionLogica RPARENT INIBLOQUE bloque FINBLOQUE;

condsElif ::= condElif
            | condElif condsElif;

condElif ::= ELIF LPARENT operacionLogica RPARENT INIBLOQUE bloque FINBLOQUE;

condElse ::= ELSE INIBLOQUE bloque FINBLOQUE;

ciclo ::= cicloDoWhile
        | cicloFor;


cicloDoWhile ::=    DO INIBLOQUE bloqueCiclo FINBLOQUE WHILE LPARENT operacionLogica RPARENT FINEXP;

cicloFor ::=      FOR LPARENT creaAsignaVar FINEXP operacionLogica FINEXP operacionAritmetica RPARENT INIBLOQUE bloqueCiclo FINBLOQUE
                | FOR LPARENT creaAsignaVar FINEXP operacionLogica FINEXP asignacion RPARENT INIBLOQUE bloqueCiclo FINBLOQUE;

bloqueCiclo ::= sentenciasCiclo;

sentenciasCiclo ::=     sentenciaCiclo
                    |   sentenciaCiclo sentenciasCiclo;

sentenciaCiclo ::=      sentencia
                    |   breakCiclo;

breakCiclo ::= BREAK FINEXP;
returnFunc ::= RETURN literal FINEXP;


// Arreglos

asignaArreglo ::=       asignaElementoArreglo FINEXP
                    |   creaAsignaArreglo:creaArr FINEXP {: RESULT = creaArr; :};

arregloSinTam ::=       tipoVarSubset:tip ID:id LPARENT_CUAD RPARENT_CUAD 
                    {:  if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ){ // Análisis semántico
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de la función: "+currentHash, "semántico");
                            RESULT = null;
                        }
                    :} ;
                     

creaArreglo ::=     tipoArreglo:tip FINEXP {: RESULT = tip; :};

creaAsignaArreglo ::=       tipoArreglo:tip EQUIV INIBLOQUE arregloValores FINBLOQUE {: RESULT = tip; :}
                        |   arregloSinTam:a EQUIV INIBLOQUE arregloValores FINBLOQUE {: RESULT = a; :}
                        |   arregloSinTam:a FINBLOQUE error {: manejoError("No se puede declarar un arreglo sin tamaño.", "sintáctico"); :};


tipoArreglo ::=     tipoVarSubset:tip expArreglo:exp 
                {:  if(exp != null){ 
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), exp.toString(), "id") == null ){ // Análisis semántico
                            RESULT = exp.toString()+": "+tip.toString();
                        }
                        else{
                            manejoError("El ID: "+exp+" ya ha sido utilizado en otra creación de variable dentro de la función: "+currentHash, "semántico");
                            RESULT = null;
                        }
                    }
                    else{
                        RESULT = null;
                    } 
                :} ;

arregloValores ::=      arregloValor
                    |   arregloValor COMA arregloValores;

arregloValor ::=       CARACTER
                    |   ENTERO
                    |   ID;

cantidadArreglo ::=     ENTERO:e
                   {:  String entero = e.toString();
                       int ent = Integer.parseInt(entero); 
                       if(ent >= 0){
                            RESULT = e; 
                        }
                        else{
                            manejoError("El número entero asignado a la cantidad del arreglo es negativo", "semántico");
                            RESULT = null;
                        }
                    :}

                    |   ID:id
                    {:  if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") != null ){
                            RESULT = id.toString();
                        }
                        else{
                            manejoError("El id: "+id+" asignado a la cantidad del arreglo no existe o no ha sido creado", "semántico");
                            RESULT = null; 
                        }
                    :} ;


asignaElementoArreglo ::=   expArreglo EQUIV operacion;

expArreglo  ::=     ID:id LPARENT_CUAD cantidadArreglo:cant RPARENT_CUAD 
                    {:  if(cant != null){
                            RESULT = id.toString();
                        }
                        else{
                            RESULT = null;
                        }
                    :} ;
                       
