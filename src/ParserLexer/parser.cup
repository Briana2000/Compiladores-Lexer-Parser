package ParserLexer;
import java_cup.runtime.*;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Collection;

// Aquí va la gramática BNF que hicimos solo que se pone con ::= en vez de la flecha 
// También se declaran los terminales y los no terminales por medio de los símbolos y las producciones

// CODIGO JAVA 

action code {:

    
:}

parser code {:
    Lexer lex;
    Symbol token;
    Boolean errores = false;
    private HashMap<String, ArrayList<String>> listaTablaSimbolos = new HashMap<String, ArrayList<String>>();
    String currentHash;
    int currentTemp = 0;
    StringBuilder codIn3D = new StringBuilder();
    ArrayList<String> elementosArray = new ArrayList<>();
    ArrayList<String> elementosParametros = new ArrayList<>();
    int contador_for = 0;
    int contador_while = 0;
    int contador_if = 0;
    int contador_else = 0;
    int contador_elif = 0;
    String fatherCurrentHash = null;
    LinkedList<String> hashTree = new LinkedList<>();
    int currentHashPos = 0;


    /* Constructor del parser, recibe como parámetro el lexer que se va a utilizar 
        Entradas: Lexer lex
        Salidas: Ninguna
        Restricciones: Ninguna
    */

    @SuppressWarnings("deprecation")
    public parser(Lexer lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
    
    /* Método que se encarga de retornar el valor booleao de errores. Indicando si hubo errores o no
        Entradas: Ninguna
        Salidas: errores
        Restricciones: Ninguna
    */
    public boolean getErrores(){
        return errores;
    }

    public StringBuilder getCodIn3D(){
        return codIn3D;
    }

    /* Método que se encarga de imprimir la tabla de símbolos
        Entradas: Ninguna
        Salidas: Ninguna
        Restricciones: Ninguna
    */
    private void imprimirTablaSimbolos(){
        for(String key: listaTablaSimbolos.keySet()){
            System.out.println("-------------------------");
            System.out.println("");
            System.out.println("Tabla de símbolos: "+key);
            System.out.println("Valores: ");
            for(String item: listaTablaSimbolos.get(key)){
                System.out.println(item);
            }

            System.out.println("");
        }

    }

     /* Método que se encarga de imprimir el string buffer del código intermedio 3 direcciones en la terminal.
        Entradas: Ninguna
        Salidas: Ninguna
        Restricciones: Ninguna
    */
    private void imprimirCodigo3D(){
        System.out.println("++++++++ CODIGO 3D +++++++++");
        System.out.println("");
        System.out.println(codIn3D.toString());
    }

    /*
        Método que se encarga de retornar la tabla de símbolos
        Entradas: Ninguna
        Salidas: tabla de símbolos
        Restricciones: Ninguna
    */
    public HashMap<String, ArrayList<String>> getTablaSimbolos(){
        return listaTablaSimbolos;
    }

    /* Método que se encarga de imprimir en consola el error sintáctico
        Entradas: String error. Error que se va a imprimir
        Salidas: Ninguna. Imprime en consola el error
        Restricciones: Ninguna
    */
    private void manejoError(String error, String tipoError){
        errores = true;
        int linea = lex.getLine();
        int columna = lex.getColumn();
        System.out.println("Error "+tipoError+": "+ error +" (en la linea: " + linea + " y columna: " + columna+")");
        System.out.println("Se continua con el análisis "+tipoError);
    } 

    /* Método que se encarga de buscar en la tabla de símbolos actual un ID y devolver su tipo.
        Entradas: lista: lista de elementos de la tabla de símbolos actual, idBuscado: ID que se requiere buscar y queBusca: si busca el ID de una variable o de una función. 
        Salidas: String o null
        Restricciones: Ninguna
    */
     private String buscarID_o_tipoID(ArrayList<String> tablaSimbolos, String idBuscado, String queBusca) {
        int treeSize = hashTree.indexOf(hashTree.get(currentHashPos));
        for (int i = treeSize; i >= 0; i--) {
            tablaSimbolos = listaTablaSimbolos.get(hashTree.get(i));
            if(queBusca.equals("id")){
                // Recorre los elementos del ArrayList
                for (String elemento : tablaSimbolos) {
                    // Divide el elemento en ID y tipo
                    String[] partes = elemento.split(": ");
                    if (partes[0].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[1]; // Se encontró el ID y se envía el tipo del ID
                    }
                    if (partes[0].equals("Parámetro") && partes[1].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[1].trim(); // Se encontró el ID y se envía el tipo del ID
                    }	
                }
            }
            else if(queBusca.equals("funcion")){
                // Recorre los elementos del ArrayList
                for (String elemento : tablaSimbolos) {
                    // Divide el elemento en ID y tipo
                    String[] partes = elemento.split(":");
                
                    if (partes[1].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[2]; // Se encontró el ID de la función y se envía el tipo de la función
                    }
                }
            }
            else if(queBusca.equals("tamañoArray")){
                // Recorre los elementos del ArrayList
                for (String elemento : tablaSimbolos) {
                    // Divide el elemento en ID y tipo
                    String[] partes = elemento.split(": ");
                
                    if (partes[0].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[2]; // Se encontró el ID de la función y se envía el tipo de la función
                    }
                }

            }
        }
        return null;       
    }


    private String existeFuncion(String idBuscado){
        Collection<ArrayList<String>> valores = listaTablaSimbolos.values();
        for (ArrayList<String> tablaSimbolos : valores){
            // Recorre los elementos del ArrayList
            for (String elemento : tablaSimbolos) {
                // Divide el elemento en ID y tipo
                String[] partes = elemento.split(":");
                if (partes[0].equals("tipo") && partes[2].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                    return partes[3].trim(); // Se encontró el ID de la función y se envía el tipo de la función
                }
            }
        }
        return null;   
    }

    private ArrayList<String> obtenerParametrosFuncion(String funcion){
        Collection<ArrayList<String>> valores = listaTablaSimbolos.values();
        ArrayList<String> parametros = new ArrayList<String>();
        for (ArrayList<String> tablaSimbolos : valores){
            // Recorre los elementos del ArrayList
            for (int i = 0; i < tablaSimbolos.size(); i++) {
                String elemento = tablaSimbolos.get(i);
                // Divide el elemento en ID y tipo
                String[] partes = elemento.split(":");
                if (partes[0].equals("tipo") && partes[2].equals(funcion)) { // Verifica si el ID coincide con el ID buscado
                    for (int j = i+1; j < tablaSimbolos.size(); j++){
                        String linea = tablaSimbolos.get(i + 1); // Se encontró el ID de la función y se envía el tipo de la función
                        if(linea.contains("Parámetro")){
                            parametros.add(linea);
                        }
                    }
                    if (parametros.size() != 0){
                        return parametros;
                    }
                }
            }
        }
        return null;   
    }
    /*  Método que se encarga de verificar si todos los elementos de una lista tienen el mismo tipo de dato.
        Entradas: lista: lista de elementos en donde cada elemento contiene un string tipo: "elemento: tipo de dato". 
        Salidas: boolean, true o false.
        Restricciones: La lista NO puede estar vacía.
    */

    private String verificarTipo_elementosArray(ArrayList<String> lista, String tipoArray){

        for (int i = 0; i < lista.size(); i++) {
            String elemento = lista.get(i);
            String[] partesElemento = elemento.split(": ");
            String tipoDatoElemento = partesElemento[1].trim();

            if (!tipoDatoElemento.equals("error_semantico")){
                if (!tipoDatoElemento.equals(tipoArray)) {
                    return partesElemento[0]; // Los tipos de datos NO son iguales
                }
            }
            else{
                return "error_semantico";
            }  
        }

        return null; // Todos los elementos tienen el mismo tipo de dato
    }

:}

init with {: :}; // define como inicializar el parser
scan with {: return token = lex.next_token(); :}; // define como conectarse con el scanner


////// Terminales ///////

// Tipos de datos
terminal INT, CHAR, STRING, FLOAT, BOOLEAN;
// Operadores Logicos
terminal TRUE, FALSE;
// Funciones
terminal RETURN, MAIN;
// Estrucutras de control
terminal IF, ELIF, ELSE, DO, WHILE, FOR, BREAK;
// Entrada y salida
terminal READ_INT, READ_FLOAT, PRINT_INT, PRINT_FLOAT, PRINT_STRING;

// Operadores
terminal PLUS, MINUS, TIMES, DIV;
terminal POWER, MODULE, PLUS_UN, MINUS_UN;
terminal AND, OR, NOT, EXCLAMACION;
terminal MAYOR_QUE, MAYOR_IGUAL, MENOR_QUE, MENOR_IGUAL, DEQUIV, DIF;

// Miscelaneos
terminal EQUIV, LPARENT, RPARENT, LPARENT_CUAD, RPARENT_CUAD;
terminal INIBLOQUE, FINBLOQUE, COMA, FINEXP;

// Literales
terminal ENTERO, DECIMAL, CADENA, CARACTER;

// Identificadores
terminal ID;


////// NO Terminales ///////  
non terminal nuevoLenguaje, tipoVar;
non terminal funciones, funcion, funcionMain, tipoRet, iniFun, endFun, identifier, bloque;
non terminal parametros, parametro, sentencias, sentencia;
non terminal creaVar, asignacion, creaAsignaVar, usaVar;
non terminal llamaFunc, parametrosLlamada, parametroLlamada, returnFunc;
non terminal literal;
non terminal input, leeInt, leeFloat, output, escribeInt, escribeFloat, escribeString;
non terminal operacion, operacionAritmetica, operadorArit, operandoArit;
non terminal operacionLogica, operadorLog, operandoLog, negacion;
non terminal operacionRelacional, operadorRel;
non terminal control, ciclo, condicional, condIf, condsElif, condElif, condElse;
non terminal cicloDoWhile, cicloFor, breakCiclo;
non terminal arregloSinTam, asignaElementoArreglo, expArreglo, cantidadArreglo; 
non terminal asignaArreglo, arregloValores, arregloValor, tipoArreglo, creaAsignaArreglo, creaArreglo;
non terminal tipoVarSubset;
non terminal beginFor, endFor, beginCiclo, endCiclo, beginCondicion, beginAlter, endAlter, evaluaCondicion;
non terminal beginWhile, endWhile, beginCicloWhile, endCicloWhile, beginCondicionWhile, evaluaCondicionWhile;
non terminal beginIf, evaluaCondicionIf, beginBloqueIf, endBloqueIf, endIf;
non terminal beginElse, endElse;
non terminal beginElif, evaluaCondicionElif, beginBloqueElif, endBloqueElif;

//non terminal nuevoLenguaje, funciones, tipoVar, creaVar, arregloConTam, parteIzAsig;
//non terminal nuevoLenguaje, funciones, tipoVar, creaVar, arregloConTam, parteIzAsig;
//non terminal nuevoLenguaje, funciones, tipoVar, creaVar, arregloConTam, parteIzAsig;

////// precedencia ///////
precedence left iniFun, endFun;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left POWER, MODULE;

precedence left AND, OR;
precedence left NOT, EXCLAMACION;
precedence left LPARENT, LPARENT_CUAD, RPARENT, RPARENT_CUAD;

////// producción de inicio ///////

start with nuevoLenguaje;

////// producciones de la gramática ///////

nuevoLenguaje ::=       funcionMain {: imprimirTablaSimbolos(); imprimirCodigo3D(); :}
                    |   funciones funcionMain {: imprimirTablaSimbolos(); imprimirCodigo3D(); :} ;


funcionMain ::=     iniFun LPARENT RPARENT INIBLOQUE bloque FINBLOQUE endFun
                |   error {: manejoError("Error de creación de función main", "sintáctico"); :};

funciones ::=       funcion {: :}
                |   funciones funcion;

funcion ::=         iniFun LPARENT parametros RPARENT INIBLOQUE bloque FINBLOQUE endFun
                |   iniFun LPARENT RPARENT INIBLOQUE bloque FINBLOQUE endFun
                |   iniFun LPARENT parametros RPARENT INIBLOQUE FINBLOQUE error {: manejoError("Funcion debe tener sentencias debido a que debe retornar un valor", "sintáctico"); :}
                |   iniFun LPARENT  RPARENT INIBLOQUE FINBLOQUE error {: manejoError("Funcion debe tener sentencias debido a que debe retornar un valor", "sintáctico"); :}
                |   error {: manejoError("Error de creación de función", "sintáctico"); :};

tipoRet ::=     INT {: RESULT = "int";:}
            |   FLOAT {: RESULT = "float";:}
            |   BOOLEAN {: RESULT = "boolean";:};

iniFun ::= tipoRet:tip identifier:id 
{:
           String tipoTabla;
           if(id.toString().equals("main")){
            tipoTabla = "tipo:funcion:"+id.toString()+": "+tip.toString();
           }
           else{
            tipoTabla = "tipo:funcion:"+id.toString()+": "+tip.toString();
           }
           if(existeFuncion(id.toString()) == null){
                ArrayList<String> listaSimbolos = new ArrayList<String>();
                currentHash = id.toString();
                listaSimbolos.add(tipoTabla);
                hashTree.addLast(currentHash);
                listaTablaSimbolos.put(currentHash, listaSimbolos);
                RESULT = tip.toString()+" "+id.toString();
                codIn3D.append("\n_"+id.toString()+"_begin:");
           }
           else{
                currentHash = id.toString();
                hashTree.addLast(currentHash);
                manejoError("Función "+id.toString()+" ya existe", "semántico");
           }
           
:};

endFun ::=  {: codIn3D.append("\n_"+hashTree.getLast()+"_end:"); hashTree.removeLast(); :};

identifier ::=  MAIN {: RESULT = "main";:}
              | ID:id {: RESULT = id.toString();:} ;

parametros ::=      parametro
                |   parametro COMA parametros;

parametro ::= tipoVar:tip ID:id 
                {: listaTablaSimbolos.get(currentHash).add("Parámetro: "+id.toString()+": "+tip.toString());:} 
            | tipoVarSubset:tip ID:id
                {: listaTablaSimbolos.get(currentHash).add("Parámetro: "+id.toString()+": "+tip.toString());:} ; 

// creación de variables 
tipoVar ::=   FLOAT {: RESULT = "float"; :}
            | STRING {: RESULT = "string"; :}
            | BOOLEAN {: RESULT = "boolean"; :} ;


tipoVarSubset ::=   INT {: RESULT = "int"; :}
                |   CHAR {: RESULT = "char"; :} ;

bloque ::= sentencias;

sentencias ::=      sentencia
                |   sentencia sentencias;

sentencia ::=       creaVar FINEXP 
                |   usaVar
                |   asignacion
                |   llamaFunc FINEXP   
                |   output      
                |   control     
                |   returnFunc
                |   creaArreglo
                |   asignaArreglo
                |   breakCiclo
                |   error {: manejoError("Error de sentencia","sintáctico"); :};

usaVar ::=      ID:id FINEXP
                {:  // ++++ Análisis semántico ++++
                    if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") != null){
                        // ++++ Código 3D ++++
                        String temp = "t"+(currentTemp++); 
                        codIn3D.append("\n"+temp+" = "+id.toString());
                    }
                    else if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") != null ){
                        // ++++ Código 3D ++++
                        String temp = "t"+(currentTemp++); 
                        codIn3D.append("\n"+temp+" = "+id.toString());
                    }
                    else{
                        // Manejo error semántico 
                        manejoError("El ID: "+id.toString()+" no existe o no ha sido creado dentro de la función "+currentHash, "semántico");
                    } 
                :}
            |   PLUS_UN ID:id FINEXP 
                {:  // ++++ Análisis semántico ++++
                    if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") != null){
                        // ++++ Código 3D ++++
                        String temp1 = "t"+(currentTemp++);
                        String temp2 = "t"+(currentTemp++);
                        String temp3 = "t"+(currentTemp++);
                        codIn3D.append("\n"+temp1+" = "+id.toString());
                        codIn3D.append("\n"+temp2+" = 1");
                        codIn3D.append("\n"+temp3+" = "+temp1+"+"+temp2);
                        codIn3D.append("\n"+id.toString()+" = "+temp3);
                    }
                    else if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") != null ){
                        // ++++ Código 3D ++++
                        String temp1 = "t"+(currentTemp++);
                        String temp2 = "t"+(currentTemp++);
                        String temp3 = "t"+(currentTemp++);
                        codIn3D.append("\n"+temp1+" = "+id.toString());
                        codIn3D.append("\n"+temp2+" = 1");
                        codIn3D.append("\n"+temp3+" = "+temp1+"+"+temp2);
                        codIn3D.append("\n"+id.toString()+" = "+temp3);
                    }
                    else{
                        // Manejo error semántico 
                        manejoError("El ID: "+id.toString()+" no existe o no ha sido creado dentro de la función "+currentHash, "semántico");
                    } 
                :}
            |   MINUS_UN ID:id FINEXP
                {:  // ++++ Análisis semántico ++++
                    if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") != null){
                        // ++++ Código 3D ++++
                        String temp1 = "t"+(currentTemp++);
                        String temp2 = "t"+(currentTemp++);
                        String temp3 = "t"+(currentTemp++);
                        codIn3D.append("\n"+temp1+" = "+id.toString());
                        codIn3D.append("\n"+temp2+" = 1");
                        codIn3D.append("\n"+temp3+" = "+temp1+"-"+temp2);
                        codIn3D.append("\n"+id.toString()+" = "+temp3);
                    }
                    else if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") != null ){
                        // ++++ Código 3D ++++
                        String temp1 = "t"+(currentTemp++);
                        String temp2 = "t"+(currentTemp++);
                        String temp3 = "t"+(currentTemp++);
                        codIn3D.append("\n"+temp1+" = "+id.toString());
                        codIn3D.append("\n"+temp2+" = 1");
                        codIn3D.append("\n"+temp3+" = "+temp1+"-"+temp2);
                        codIn3D.append("\n"+id.toString()+" = "+temp3);
                    }
                    else{
                        // Manejo error semántico 
                        manejoError("El ID: "+id.toString()+" no existe o no ha sido creado dentro de la función "+currentHash, "semántico");
                    } 
                :} 
                ;

creaVar ::=     tipoVar:tip ID:id  
               {:   // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :} 

            |   tipoVarSubset:tip ID:id  
                {:  // ++++ Análisis semántico ++++
                    
                    //System.out.println(fatherCurrentHash);
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :}  ;

asignacion ::=      creaAsignaVar FINEXP
                |   ID:id EQUIV literal:lit FINEXP 
                    {:  // ++++ Análisis semántico ++++
                        if(fatherCurrentHash != null){
                            if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") != null){ 
                                if(!lit.toString().equals("error_semantico")){
                                    String[] partes = lit.toString().split("::");
                                    // ++++ Código 3D ++++
                                    String temp = "t"+(currentTemp++); 
                                    codIn3D.append("\n"+id.toString()+" = "+partes[1].toString());
                                    RESULT = partes[0].toString()+"::"+temp; 
                                }
                                else{
                                    RESULT = "error_semantico";
                                }
                            }
                            else{
                                //Manejo error semántico
                                manejoError("El ID: "+id+" no ha sido creado dentro de la función "+fatherCurrentHash, "semántico");
                                RESULT = "error_semantico";
                            }
                        }
                        else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") != null){
                            if(!lit.toString().equals("error_semantico")){
                                String[] partes = lit.toString().split("::");
                                // ++++ Código 3D ++++
                                String temp = "t"+(currentTemp++); 
                                codIn3D.append("\n"+id.toString()+" = "+partes[1].toString());
                                RESULT = partes[0].toString()+"::"+temp; 
                            }
                            else{
                                RESULT = "error_semantico";
                            }
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" no ha sido creado dentro de la función ", "semántico");
                            RESULT = "error_semantico";
                        }
                    :} 
                    
                |   ID:id EQUIV input:input FINEXP  {:
                        String[] partes = input.toString().split("::");
                        String tipo = partes[0].toString();
                        String tipoId = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id");

                        if(tipoId.equals(tipo)){
                            // ++++ Código 3D ++++
                            String temp = "t"+(currentTemp++); 
                            codIn3D.append("\n"+id.toString()+" = "+partes[1].toString());
                            RESULT = partes[0].toString()+"::"+temp; 
                        }
                        else if(tipoId == null){
                            //Manejo error semántico
                            manejoError("El ID: "+id+" no ha sido creado dentro de la función", "semántico");
                            RESULT = "error_semantico";
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" tiene un tipo diferente al del input", "semántico");
                            RESULT = "error_semantico";
                        }
                    :};

creaAsignaVar ::=    creaVar:cv EQUIV literal:lit 
                     {: // ++++ Análisis semántico ++++
                        if(!cv.equals("error_semantico") && !lit.equals("error_semantico")){
                            String[] partes_cv = cv.toString().split(": ");
                            String[] partes_lit = lit.toString().split("::");
                            if(!partes_cv[1].equals(partes_lit[0])){
                                System.out.println("++++++ El tipo de la variable es: "+partes_cv[1]);
                                System.out.println("++++++ El tipo del literal es: "+partes_lit[0]);
                                manejoError("El tipo del ID: "+partes_cv[0]+" no corresponde con los valores asignados", "semántico") ;
                                RESULT = "error_semantico";
                            }
                            else{ 
                                // ++++ Código 3D ++++
                                codIn3D.append("\n"+partes_cv[0]+" = "+partes_lit[1]);
                            }
                        }
                        else{
                            RESULT = "error_semantico";
                        }
                     :}
                  |  creaVar:cv EQUIV input:input {:
                        String[] partes = input.toString().split("::");
                        String tipo = partes[0].toString();
                        String[] partesLadoIzq = cv.toString().split(": ");

                        if(partesLadoIzq[1].equals(tipo)){
                            // ++++ Código 3D ++++
                            String temp = "t"+(currentTemp++); 
                            codIn3D.append("\n"+partesLadoIzq[0].toString()+" = "+partes[1].toString());
                            RESULT = partes[0].toString()+"::"+temp; 
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+ partesLadoIzq[0].toString() +" no ha sido creado dentro de la función", "semántico");
                            RESULT = "error_semantico";
                        }
                    :} ; //***********************************FALTAAAAA codigo 3D y semántico
 
                //|   tipoVar ID EQUIV arreglo FINEXP
                //|   tipoVar ID EQUIV arregloConTam FINEXP

literal ::=     operacion:op {:RESULT = op ;:}// operacion contiene operando aritmetico que a su vez contiene entero, decimal, id
            |   CADENA:cad 
                {: // ++++ Código 3D ++++
                   String temp = "t"+(currentTemp++); 
                   codIn3D.append("\n"+temp+" = "+cad.toString());
                   RESULT = "string::"+temp; 
               :}
            |   CARACTER:car 
                {: // ++++ Código 3D ++++
                   String temp = "t"+(currentTemp++); 
                   codIn3D.append("\n"+temp+" = "+car.toString());
                   RESULT = "char::"+temp; 
                :}
            |   BOOLEAN 
            |   error {: manejoError("Error de literal", "sintáctico"); :};

operacion ::=       operacionLogica:opLog {: RESULT = opLog; :} ;

operacionAritmetica ::=     operandoArit:opeArit {: RESULT = opeArit; :}
                        |   PLUS_UN operandoArit:opeArit 
                            {:  // ++++ Análisis semántico ++++
                                if(!opeArit.toString().equals("error_semantico")){
                                    String[] partes = opeArit.toString().split("::");
                                    // ++++ Código 3D ++++
                                    String temp1 = "t"+(currentTemp++);
                                    String temp2 = "t"+(currentTemp++);
                                    codIn3D.append("\n"+temp1+" = 1");
                                    codIn3D.append("\n"+temp2+" = "+partes[1].toString()+" + "+temp1);
                                    codIn3D.append("\n"+partes[2].toString()+" = "+temp2);
                                    RESULT = partes[0].toString()+"::"+temp2;
                                }
                                else{
                                    RESULT = "error_semantico";
                                }
                            :}

                        |   MINUS_UN operandoArit:opeArit 
                            {:  // ++++ Análisis semántico ++++
                                if(!opeArit.toString().equals("error_semantico")){
                                    String[] partes = opeArit.toString().split("::");
                                    // ++++ Código 3D ++++
                                    String temp1 = "t"+(currentTemp++);
                                    String temp2 = "t"+(currentTemp++);
                                    codIn3D.append("\n"+temp1+" = 1");
                                    codIn3D.append("\n"+temp2+" = "+partes[1].toString()+" - "+temp1);
                                    codIn3D.append("\n"+partes[2].toString()+" = "+temp2);
                                    RESULT = partes[0].toString()+"::"+temp2;
                                }
                                else{
                                    RESULT = "error_semantico";
                                }
                            :}

                        |   operacionAritmetica:operacion1 operadorArit:operador operacionAritmetica:operacion2
                            {: if (!operacion1.equals("error_semantico") && !operacion2.equals("error_semantico")){
                                    String[] op1_partes = operacion1.toString().split("::");
                                    String[] op2_partes = operacion2.toString().split("::");
                                    if(op1_partes[0].equals(op2_partes[0])){ // si los tipos de las operaciones son iguales
                                        // ++++ Código 3D ++++
                                        String temp = "t"+(currentTemp++); 
                                        codIn3D.append("\n"+temp+" = "+op1_partes[1]+" "+operador.toString()+" "+op2_partes[1]);
                                        
                                        RESULT = op1_partes[0]+"::"+temp;
                                    }
                                    else if(!op1_partes[0].equals(op2_partes[0])){
                                        System.out.println("+++++++++El tipo de la operación Artimética 1 es: "+op1_partes[0].toString());
                                        System.out.println("+++++++++El tipo de la operación Aritmética 2 es: "+op2_partes[0].toString());
                                        manejoError("No se pueden operar valores o variables de diferentes tipos de datos", "semántico");
                                        RESULT = "error_semantico";
                                    }
                                }
                                else{
                                    RESULT = "error_semantico"; 
                                }
                            :}
                        |   LPARENT operacionAritmetica:operacion RPARENT 
                            {:  if(!operacion.equals("error_semantico")){
                                    String[] partes = operacion.toString().split("::");
                                    String temp = "t"+(currentTemp++);
                                    codIn3D.append("\n"+temp+" = "+"("+partes[1]+")");
                                    RESULT = partes[0]+"::"+temp;
                                } 
                                else{
                                    RESULT = "error_semantico";
                                } 
                            :}                            
                        |   MINUS operacionAritmetica:operacion 
                            {:  if(!operacion.equals("error_semantico")){
                                    String temp = "t"+(currentTemp++);
                                    String[] partes = operacion.toString().split("::");
                                    codIn3D.append("\n"+temp+" = "+"-"+partes[1].toString());
                                    RESULT = partes[0]+"::"+temp;
                                } 
                                else{
                                    RESULT = "error_semantico";
                                }
                            :} ; 

operadorArit ::=    PLUS {: RESULT = "+"; :}
                |   MINUS {: RESULT = "-"; :}
                |   TIMES {: RESULT = "*"; :}
                |   DIV {: RESULT = "/"; :}
                |   POWER {: RESULT = "**"; :}
                |   MODULE {: RESULT = "~"; :} ;

operandoArit ::=        ENTERO:ent 
                        {: // ++++ Código 3D ++++
                            String temp = "t"+(currentTemp++); 
                            codIn3D.append("\n"+temp+" = "+ent.toString());
                            RESULT = "int::"+temp; 
                        :}
                    |   DECIMAL:dec
                        {: // ++++ Código 3D ++++
                            String temp = "t"+(currentTemp++); 
                            codIn3D.append("\n"+temp+" = "+dec.toString());
                            RESULT = "float::"+temp; 
                        :}
                    |   ID:id 
                    {:  String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id");
                        if(tipo != null){
                            // ++++ Código 3D ++++
                            String temp = "t"+(currentTemp++); 
                            codIn3D.append("\n"+temp+" = "+id.toString());
                            RESULT = tipo+"::"+temp+"::"+id.toString(); 
                        }
                        else if (fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") != null ){
                            // ++++ Código 3D ++++
                            String tipo2 = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id");
                            String temp = "t"+(currentTemp++); 
                            codIn3D.append("\n"+temp+" = "+id.toString());
                            RESULT = tipo2+"::"+temp+"::"+id.toString();
                        }
                        else{
                            manejoError("El id: "+id+" no existe o no ha sido creado", "semántico");
                            RESULT = "error_semantico";
                        } 
                    :}

                    |   llamaFunc:llamaF {:
                        if (!llamaF.toString().equals("error_semantico")){
                            String[] partes = llamaF.toString().split("::");
                            String tipo = partes[0].toString();
                            String temp = partes[1].toString();
                            String id = partes[2].toString();
                            RESULT = tipo+"::"+temp+"::call "+id;
                        }
                        else{
                            RESULT = "error_semantico";
                        }
                    :}
                    |   expArreglo:expArr
                    {:  if(!expArr.toString().equals("error_semantico")){
                            String[] partes = expArr.toString().split("::");
                            String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes[0].toString(), "id");
                            if( tipo != null){
                                // ++++ Código 3D ++++
                                String temp = "t"+(currentTemp++); 
                                codIn3D.append("\n"+temp+" = "+partes[0].toString()+"["+partes[1].toString()+"]");
                                RESULT = tipo+"::"+temp;
                            }
                            else if(fatherCurrentHash != null){
                                String tipo2 = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes[0].toString(), "id");
                                if(tipo2 != null){
                                    // ++++ Código 3D ++++
                                    String temp = "t"+(currentTemp++); 
                                    codIn3D.append("\n"+temp+" = "+partes[0].toString()+"["+partes[1].toString()+"]");
                                    RESULT = tipo2+"::"+temp;
                                }
                                else{
                                    // Manejo error semántico
                                    manejoError("El id: "+partes[0].toString()+" no existe o no ha sido creado", "semántico");
                                    RESULT = "error_semantico";
                                }
                            }
                            else{
                                // Manejo error semántico
                                manejoError("El id: "+partes[0].toString()+" no existe o no ha sido creado", "semántico");
                                RESULT = "error_semantico";
                            }
                        }
                        else{
                            RESULT = "error_semantico";
                        }
                    :} ;

operacionRelacional ::=     operacionAritmetica:operacion1 operadorRel:operador operacionAritmetica:operacion2 
                            {: if (!operacion1.equals("error_semantico") && !operacion2.equals("error_semantico")){
                                    String[] op1_partes = operacion1.toString().split("::");
                                    String[] op2_partes = operacion2.toString().split("::");
                                    if(op1_partes[0].equals(op2_partes[0])){ // si los tipos de las operaciones son iguales
                                        // ++++ Código 3D ++++
                                        String temp = "t"+(currentTemp++); 
                                        codIn3D.append("\n"+temp+" = "+op1_partes[1]+" "+operador.toString()+" "+op2_partes[1]);
                                        RESULT = "boolean::"+temp;
                                    }
                                    else if(!op1_partes[0].equals(op2_partes[0])){
                                        System.out.println("+++++++++El tipo de la operación Relacional 1 es: "+operacion1.toString());
                                        System.out.println("+++++++++El tipo de la operación Relacional 2 es: "+operacion2.toString());
                                        manejoError("No se pueden hacer operaciones relacionales con valores o variables de diferentes tipos de datos", "semántico");
                                        RESULT = "error_semantico";
                                    }
                                }
                                else{
                                    RESULT = "error_semantico"; 
                                }
                                :} ;

operadorRel ::=     MAYOR_QUE {: RESULT = ">"; :}
                |   MAYOR_IGUAL {: RESULT = ">="; :}
                |   MENOR_QUE {: RESULT = "<"; :}
                |   MENOR_IGUAL {: RESULT = "<="; :}
                |   DEQUIV  {: RESULT = "=="; :}
                |   DIF {: RESULT = "!="; :} ;

operacionLogica ::=     operandoLog: opLog 
                        {:  // ++++ Código 3D ++++
                            String temp = "t"+(currentTemp++); 
                            codIn3D.append("\n"+temp+" = "+opLog.toString());
                            RESULT = "boolean::"+temp;
                        :}
                    |   operacionRelacional: opRel {: RESULT = opRel; :}
                    |   operacionAritmetica:opArit {: RESULT = opArit; :}
                    |   operacionLogica:operacion1 operadorLog:operador operacionLogica:operacion2 
                        {: if (!operacion1.equals("error_semantico") && !operacion2.equals("error_semantico")){
                                String[] op1_partes = operacion1.toString().split("::");
                                String[] op2_partes = operacion2.toString().split("::");
                                // ++++ Código 3D ++++
                                String temp = "t"+(currentTemp++); 
                                codIn3D.append("\n"+temp+" = "+op1_partes[1]+" "+operador.toString()+" "+op2_partes[1]);
                                RESULT = "boolean::"+temp;
                            }
                            else{
                                RESULT = "error_semantico"; 
                            }
                        :}

                    |   LPARENT operacionLogica:opLog RPARENT 
                        {: if(!opLog.equals("error_semantico")){
                            String[] partes = opLog.toString().split("::");
                            String temp = "t"+(currentTemp++);
                            codIn3D.append("\n"+temp+" = "+"("+partes[1]+")");
                            RESULT = partes[0]+"::"+temp;
                            } 
                            else{
                                RESULT = "error_semantico";
                            } 
                        :} %prec LPARENT

                    |   negacion:neg operacionLogica:opLog 
                        {: if(!opLog.equals("error_semantico")){
                            String temp = "t"+(currentTemp++);
                            String[] partes = opLog.toString().split("::");
                            codIn3D.append("\n"+temp+" = "+neg.toString()+partes[1].toString());
                            RESULT = "boolean::"+temp;
                            } 
                            else{
                                RESULT = "error_semantico";
                            }
                        :} ; 

operandoLog ::=     TRUE {: RESULT = "true"; :}
                |   FALSE {: RESULT = "false"; :} ;


operadorLog ::=     AND {: RESULT = "^"; :}
                |   OR {: RESULT = "#"; :} ;

negacion ::=        NOT {: RESULT = "not"; :}
                |   EXCLAMACION {: RESULT = "!"; :} ;


llamaFunc ::=       ID:id LPARENT parametrosLlamada RPARENT 
                {:  
                    
                    String tipoFunc = existeFuncion(id.toString());
                    if(tipoFunc != null){
                        ArrayList<String> parametrosFuncion = obtenerParametrosFuncion(id.toString());
                       if (parametrosFuncion.size() == elementosParametros.size()){
                            for(int i=0; i<parametrosFuncion.size(); i++){
                                String[] partesParametro = parametrosFuncion.get(i).split(":");
                                String[] partesElemento = elementosParametros.get(i).split(":");
                                if(partesParametro[2].trim().equals(partesElemento[0])){
                                    // ++++ Código 3D ++++
                                    codIn3D.append("\nparam t"+ (currentTemp-1));
                                }
                                else{
                                    manejoError("El tipo de dato del parámetro: "+partesParametro[1]+" no coincide con el tipo de dato del elemento: "+partesElemento[1], "semántico");
                                    RESULT = "error_semantico";
                                }
                            }
                            // ++++ Código 3D ++++
                            String temp = "t"+(currentTemp++);
                            codIn3D.append("\n"+temp+"= call "+id.toString()+ ", " + parametrosFuncion.size());
                            RESULT = tipoFunc+"::"+temp +"::"+id.toString()+", "+ parametrosFuncion.size();
                       }
                       else{
                            String tamaño1 = String.valueOf(parametrosFuncion.size());
                            String tamaño2 = String.valueOf(elementosParametros.size());
                            System.out.println("**** El número 1 es: "+tamaño1);
                            System.out.println("**** El número 2 es: "+tamaño2);
                           manejoError("El número de parámetros de la función: "+id+" no coincide con el número de elementos en la llamada", "semántico");
                           RESULT = "error_semantico";
                       }
                    }
                    else{
                        // Manejo error semántico
                        manejoError("La función: "+id+" no existe o no ha sido creada", "semántico");
                        RESULT = "error_semantico";
                    }
                    elementosParametros.clear();
                :}
                |   ID LPARENT RPARENT;


parametrosLlamada ::=       parametroLlamada:lit 
                        {:  
                            elementosParametros.add(lit.toString());
                        :}
                        |   parametroLlamada:lit COMA parametrosLlamada 
                        {:  
                            elementosParametros.add(lit.toString());
                        :};

parametroLlamada ::=    literal:lit {: RESULT=lit.toString(); :};
////// I/O ///////

// Input
input ::=       leeInt:r {: RESULT=r; :}
            |   leeFloat:r {: RESULT=r; :};
leeInt ::= READ_INT LPARENT RPARENT {:
                        // ++++ Código 3D ++++
                        codIn3D.append("\nt"+(currentTemp-1)+" = call readInt");
                        RESULT = "int::t"+(currentTemp-1);
                    :};
leeFloat ::= READ_FLOAT LPARENT RPARENT {:
                        // ++++ Código 3D ++++
                        codIn3D.append("\nt"+(currentTemp-1)+" call readFloat" );
                        RESULT = "float::t"+(currentTemp-1);
                    :};

// Output
output ::=      escribeInt 
            |   escribeFloat
            |   escribeString;
        
escribeInt ::=      PRINT_INT LPARENT ID:id RPARENT FINEXP {: 
                        String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id");
                        if(tipo.equals("int")){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ncall printInt t"+(currentTemp-1));
                        }
                        else{
                            manejoError("El tipo de dato del elemento: "+id.toString()+" no coincide con el tipo de dato del parámetro: int", "semántico");
                        }
                    :}
                |   PRINT_INT LPARENT ENTERO RPARENT FINEXP
                    {:  
                            codIn3D.append("\ncall printInt t"+(currentTemp-1));
                    :};


escribeFloat ::=    PRINT_FLOAT LPARENT ID:id RPARENT FINEXP {:
                        String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id");
                        if(tipo.equals("float")){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ncall printFloat t"+(currentTemp-1));
                        }
                        else{
                            manejoError("El tipo de dato del elemento: "+id.toString()+" no coincide con el tipo de dato del parámetro: float", "semántico");
                        }
                    :}
                |   PRINT_FLOAT LPARENT DECIMAL RPARENT FINEXP
                    {:  
                            codIn3D.append("\nprintFloat t"+(currentTemp-1));
                    :};

escribeString ::= PRINT_STRING LPARENT ID:id RPARENT FINEXP {:
                        String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id");
                        if(tipo.equals("string")){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ncall printString t"+(currentTemp-1));
                        }
                        else{
                            manejoError("El tipo de dato del elemento: "+id.toString()+" no coincide con el tipo de dato del parámetro: string", "semántico");
                        }
                    :}
                | PRINT_STRING LPARENT CADENA RPARENT FINEXP
                    {:  
                            codIn3D.append("\ncall printString t"+(currentTemp-1));
                    :};

////// Control de flujo ///////

control ::= condicional | ciclo;

condicional ::= condIf condsElif condElse endIf
            |   condIf condsElif endIf
            |   condIf condElse endIf
            |   condIf endIf;

condIf ::=  beginIf IF LPARENT operacionLogica evaluaCondicionIf RPARENT INIBLOQUE beginBloqueIf bloque endBloqueIf FINBLOQUE;

beginIf ::= {: String tipoTabla = "tipo:condicional:if";
                ArrayList<String> listaSimbolos = new ArrayList<String>();
                
                fatherCurrentHash = currentHash;
                currentHash = "if_"+(++contador_if)+"_"+ hashTree.get(currentHashPos);
                listaSimbolos.add(tipoTabla);
                hashTree.addLast(currentHash);
                currentHashPos++;
                listaTablaSimbolos.put(currentHash, listaSimbolos);
                codIn3D.append("\n_if_" + contador_if + ":");
                :} ;

endIf ::= {:    codIn3D.append("\n_end_if_"+(contador_if)+":"); :} ;

evaluaCondicionIf ::= {:    int temporalAnterior = currentTemp;
                            codIn3D.append("\nif t"+(--temporalAnterior)+" goto _if_"+(contador_if)+"_bloque");
                            codIn3D.append("\ngoto _end_if_"+(contador_if)+"_bloque");
                        :} ;

beginBloqueIf ::= {: codIn3D.append("\n_if_"+(contador_if)+"_bloque:"); :} ;

endBloqueIf ::= {:  hashTree.removeLast();
                    currentHashPos--;  
                    currentHash = hashTree.getLast();
                    if (hashTree.size() > 1)
                        fatherCurrentHash = hashTree.get(currentHashPos-1);
                    else
                        fatherCurrentHash = null;  
                    codIn3D.append("\ngoto _end_if_"+(contador_if)); 
                    codIn3D.append("\n_end_if_"+(contador_if)+"_bloque:"); :} ;

condsElif ::= condElif
            | condElif condsElif;

condElif ::= beginElif ELIF LPARENT operacionLogica evaluaCondicionElif RPARENT INIBLOQUE beginBloqueElif bloque endBloqueElif FINBLOQUE;

beginElif ::= {: String tipoTabla = "tipo:condicional:elif";
                ArrayList<String> listaSimbolos = new ArrayList<String>();
                
                fatherCurrentHash = currentHash;
                currentHash = "if_"+(contador_if)+"_elif_"+(++contador_elif)+ hashTree.get(currentHashPos);
                listaSimbolos.add(tipoTabla);
                hashTree.addLast(currentHash);
                currentHashPos++;
                listaTablaSimbolos.put(currentHash, listaSimbolos);
                :} ;

evaluaCondicionElif ::= {:    int temporalAnterior = currentTemp;
                            codIn3D.append("\nif t"+(--temporalAnterior)+" goto _if_"+(contador_if)+"_elif_"+(contador_elif)+"_bloque");
                            codIn3D.append("\ngoto _end_if_"+(contador_if)+"_elif_"+(contador_elif)+"_bloque");
                        :} ;

beginBloqueElif ::= {: codIn3D.append("\n_if_"+(contador_if)+"_elif_"+(contador_elif)+"_bloque:"); :} ;

endBloqueElif ::= {: 
                        hashTree.removeLast();
                        currentHashPos--;  
                        currentHash = hashTree.getLast();
                        if (hashTree.size() > 1)
                            fatherCurrentHash = hashTree.get(currentHashPos-1);
                        else
                            fatherCurrentHash = null;  
                        codIn3D.append("\ngoto _end_if_"+(contador_if)); 
                        codIn3D.append("\n_end_if_"+(contador_if)+"_elif_"+(contador_elif)+"_bloque:"); 
                        :} ;


condElse ::= beginElse ELSE INIBLOQUE bloque FINBLOQUE endElse;

beginElse ::= {: String tipoTabla = "tipo:condicional:else";
                ArrayList<String> listaSimbolos = new ArrayList<String>();
                
                fatherCurrentHash = currentHash;
                currentHash = "if_"+(contador_if)+"_else_"+(++contador_else)+ hashTree.get(currentHashPos);
                listaSimbolos.add(tipoTabla);
                hashTree.addLast(currentHash);
                currentHashPos++;
                listaTablaSimbolos.put(currentHash, listaSimbolos);
                codIn3D.append("\n_if_"+ contador_if +"_else_" + contador_else + ":");
                :} ;

endElse ::= {:
                hashTree.removeLast();
                currentHashPos--;  
                currentHash = hashTree.getLast();
                if (hashTree.size() > 1)
                    fatherCurrentHash = hashTree.get(currentHashPos-1);
                else
                    fatherCurrentHash = null;  
                codIn3D.append("\n_end_if_else_"+(contador_else)+":"); :} ;


ciclo ::= cicloDoWhile
        | cicloFor;


cicloDoWhile ::=    beginWhile DO INIBLOQUE beginCicloWhile bloque endCicloWhile FINBLOQUE WHILE LPARENT beginCondicionWhile operacionLogica evaluaCondicionWhile RPARENT FINEXP endWhile;

beginWhile ::= {: String tipoTabla = "tipo:ciclo:while";
                ArrayList<String> listaSimbolos = new ArrayList<String>();
                
                fatherCurrentHash = currentHash;
                currentHash = "while_"+(currentHashPos + 1)+"_"+ hashTree.get(currentHashPos);
                listaSimbolos.add(tipoTabla);
                hashTree.addLast(currentHash);
                currentHashPos++;
                listaTablaSimbolos.put(currentHash, listaSimbolos);
                codIn3D.append("\n_begin_while_"+(contador_while)+":");
            :} ;

endWhile ::=  {:  
                hashTree.removeLast();
                currentHashPos--;  
                currentHash = hashTree.getLast();
                if (hashTree.size() > 1)
                    fatherCurrentHash = hashTree.get(currentHashPos-1);
                else
                    fatherCurrentHash = null;       
                codIn3D.append("\n_end_while_"+(contador_while)+":"); 
            :} ;

beginCicloWhile ::= {: codIn3D.append("\n_begin_while_"+(contador_while)+"_bloque:"); :}; 

endCicloWhile ::= {: codIn3D.append("\ngoto _begin_while_"+(contador_while)+"_condicion");
                codIn3D.append("\n_end_while_"+(contador_while)+"_bloque:"); :} ;

beginCondicionWhile ::= {: codIn3D.append("\n_begin_while_"+(contador_while)+"_condicion:"); 
                            currentHashPos--; :};

evaluaCondicionWhile ::= {: int temporalAnterior = currentTemp;
                       currentHashPos++;
                       codIn3D.append("\nif t"+(--temporalAnterior)+" goto _begin_while_"+(contador_while)+"_bloque");
                       codIn3D.append("\ngoto _end_while_"+(contador_while)+"_bloque"); :} ;
                    

// Ya sirven pero en un for enciclado no se estan contando las variables definidas en la funcion ///// ¿??
cicloFor ::=      beginFor FOR LPARENT creaAsignaVar FINEXP beginCondicion operacionLogica evaluaCondicion FINEXP beginAlter operacionAritmetica endAlter RPARENT INIBLOQUE beginCiclo bloque endCiclo FINBLOQUE endFor
                | beginFor FOR LPARENT creaAsignaVar FINEXP beginCondicion operacionLogica evaluaCondicion FINEXP beginAlter asignacion endAlter RPARENT INIBLOQUE beginCiclo bloque endCiclo FINBLOQUE endFor ;

beginFor ::= {: String tipoTabla = "tipo:ciclo:for";
                ArrayList<String> listaSimbolos = new ArrayList<String>();
                fatherCurrentHash = currentHash;
                currentHash = "for_"+(++contador_for)+"_"+fatherCurrentHash;
                listaSimbolos.add(tipoTabla);
                hashTree.addLast(currentHash);
                currentHashPos++;
                listaTablaSimbolos.put(currentHash, listaSimbolos);
                codIn3D.append("\n_begin_for_"+(contador_for)+":");
            :} ;

endFor ::=  {:  
                currentHash = fatherCurrentHash;
                currentHash = hashTree.get(currentHashPos-1);
                hashTree.removeLast();
                currentHashPos--;
                fatherCurrentHash = null;                
                codIn3D.append("\n_end_for_"+(contador_for)+":"); 
            :} ;

beginCiclo ::= {: codIn3D.append("\n_begin_for_"+(contador_for)+"_bloque:"); :}; 

endCiclo ::= {: codIn3D.append("\ngoto _begin_for_"+(contador_for)+"_alter");
                codIn3D.append("\n_end_for_"+(contador_for)+"_bloque:"); :} ;

beginCondicion ::= {: codIn3D.append("\n_begin_for_"+(contador_for)+"_condicion:"); :};

evaluaCondicion ::= {: int temporalAnterior = currentTemp;
                       codIn3D.append("\nif t"+(--temporalAnterior)+" goto _begin_for_"+(contador_for)+"_bloque");
                       codIn3D.append("\ngoto _end_for_"+(contador_for)+"_bloque"); :} ;
                    
beginAlter ::= {: codIn3D.append("\n_begin_for_"+(contador_for)+"_alter:"); :};

endAlter ::= {: codIn3D.append("\ngoto _begin_for_"+(contador_for)+"_condicion"); :};


breakCiclo ::= BREAK FINEXP;

returnFunc ::= RETURN literal:lit FINEXP {: // Chequear si el tipo de la funcion es igual al tipo del literar
                                        int temporalAnterior = currentTemp;
                                        int treeSize = hashTree.indexOf(hashTree.get(currentHashPos));
                                        String tipoFunc = "";
                                        for (int i = treeSize; i >= 0; i--) {
                                            tipoFunc = existeFuncion(hashTree.get(i));
                                        }
                                        String[] partes = lit.toString().split("::");
                                        String tipo = partes[0];
                                        if (tipoFunc != null && tipoFunc.equals(tipo)) {
                                            codIn3D.append("\nreturn t"+(--temporalAnterior));
                                        }
                                        else{
                                            manejoError("El tipo de la función no es igual al tipo del return", "semántico");
                                        }
                                    :};


// Arreglos

asignaArreglo ::=       asignaElementoArreglo FINEXP
                    |   creaAsignaArreglo FINEXP ;

arregloSinTam ::=       tipoVarSubset:tip ID:id LPARENT_CUAD RPARENT_CUAD 
                    {:  // ++++ Análisis semántico ++++
                        if(fatherCurrentHash != null){
                            if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){ 
                                // ++++ Código 3D ++++
                                codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                                RESULT = id.toString()+": "+tip.toString();
                            }
                            else{
                                //Manejo error semántico
                                manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de la función", "semántico");
                                RESULT = "error_semantico";
                            }
                        }
                        else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de la función", "semántico");
                            RESULT = "error_semantico";
                        }
                    :} ;
                     

creaArreglo ::=     tipoArreglo FINEXP ;

creaAsignaArreglo ::=       tipoArreglo:parteIzArreglo EQUIV INIBLOQUE arregloValores FINBLOQUE 
                            {:  if(!parteIzArreglo.toString().equals("error_semantico")){
                                    String[] partes_parteIzArr = parteIzArreglo.toString().split("::");
                                    int tamañoArreglo = Integer.parseInt(partes_parteIzArr[3]);
                                     // ++++ Análisis semántico ++++ 
                                    if(tamañoArreglo == elementosArray.size()){
                                        String validacion = verificarTipo_elementosArray(elementosArray, partes_parteIzArr[1]);
                                        if(validacion == null){
                                            // ++++ Código 3D ++++
                                            int j = elementosArray.size()-1;
                                            for(int i = 0; i < elementosArray.size();i++){
                                                String temp = "t"+(currentTemp++);
                                                String[] partes_elemArr = elementosArray.get(i).split(": ");
                                                codIn3D.append("\n"+temp+" = "+partes_elemArr[0].toString());
                                                codIn3D.append("\n"+partes_parteIzArr[0]+"["+j+"]"+" = "+temp);
                                                j--;
                                            }
                                            elementosArray.clear();
                                            //RESULT = "Hola";
                                        }
                                        else if(validacion.equals("error_semantico")){
                                            elementosArray.clear();
                                            RESULT = "error_semantico";
                                        }
                                        else{
                                            // Manejo error semántico
                                            elementosArray.clear();
                                            manejoError("El elemento: "+validacion+" del array tiene un tipo de dato distinto al definido en la declaración del array", "semántico");
                                            RESULT = "error_semantico";
                                        }
                                    }
                                    else {
                                        elementosArray.clear();
                                        // Manejo error semántico
                                        manejoError("El array tiene una cantidad de elementos diferente a la especificada", "semántico");
                                        RESULT = "error_semantico";
                                    }
                                }
                                else{
                                    RESULT = "error_semantico";
                                }
                            :}
                        |   arregloSinTam:parteIzArreglo EQUIV INIBLOQUE arregloValores FINBLOQUE 
                            {:  if(!parteIzArreglo.toString().equals("error_semantico")){
                                    String[] partes_parteIzArr = parteIzArreglo.toString().split(": ");
                                    int tamañoArreglo = elementosArray.size();
                                    // +++ Tabla de símbolos ++++ 
                                    listaTablaSimbolos.get(currentHash).add(partes_parteIzArr[0].toString()+": "+partes_parteIzArr[1].toString()+": "+String.valueOf(tamañoArreglo));
                                    // ++++ Análisis semántico ++++ 
                                    String validacion = verificarTipo_elementosArray(elementosArray, partes_parteIzArr[1]);
                                    if(validacion == null){
                                        // ++++ Código 3D ++++
                                        int j = elementosArray.size()-1;
                                        for(int i = 0; i < elementosArray.size();i++){
                                            String temp = "t"+(currentTemp++);
                                            String[] partes_elemArr = elementosArray.get(i).split(": ");
                                            codIn3D.append("\n"+temp+" = "+partes_elemArr[0].toString());
                                            codIn3D.append("\n"+partes_parteIzArr[0]+"["+j+"]"+" = "+temp);
                                            j--;
                                        }
                                        elementosArray.clear();
                                        //RESULT = "Hola";
                                    }
                                    else if(validacion.equals("error_semantico")){
                                        elementosArray.clear();
                                        RESULT = "error_semantico";
                                    }
                                    else{
                                        // Manejo error semántico
                                        elementosArray.clear();
                                        manejoError("El elemento: "+validacion+" del array tiene un tipo de dato distinto al definido en la declaración del array", "semántico");
                                        RESULT = "error_semantico";
                                    }
                                }
                                else{
                                    RESULT = "error_semantico";
                                }
                            :}
                        |   arregloSinTam:a FINBLOQUE error {: manejoError("No se puede declarar un arreglo sin tamaño.", "sintáctico"); :};


tipoArreglo ::=     tipoVarSubset:tip expArreglo:exp 
                {:  if(!exp.equals("error_semantico")){
                        // ++++ Análisis semántico ++++ 
                        String[] partes = exp.toString().split("::"); 
                        if(fatherCurrentHash != null){
                            if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes[0].toString(), "id") == null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes[0].toString(), "id") == null){ 
                                listaTablaSimbolos.get(currentHash).add(partes[0].toString()+": "+tip.toString()+": "+partes[1].toString());
                                // ++++ Código 3D ++++
                                String temp = "t"+(currentTemp++); 
                                codIn3D.append("\ndata_"+tip.toString()+" "+partes[0].toString());
                                RESULT = partes[0].toString()+"::"+tip.toString()+"::"+temp+"::"+partes[1].toString();
                            }
                            else{
                                // Manejo error semántico
                                manejoError("El ID: "+partes[0].toString()+" ya ha sido utilizado en otra creación de variable dentro de la función "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }
                        }
                        else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes[0].toString(), "id") == null){
                                listaTablaSimbolos.get(currentHash).add(partes[0].toString()+": "+tip.toString()+": "+partes[1].toString());
                                // ++++ Código 3D ++++
                                String temp = "t"+(currentTemp++); 
                                codIn3D.append("\ndata_"+tip.toString()+" "+partes[0].toString());
                                RESULT = partes[0].toString()+"::"+tip.toString()+"::"+temp+"::"+partes[1].toString();
                        }
                        else{
                            // Manejo error semántico
                            manejoError("El ID: "+partes[0].toString()+" ya ha sido utilizado en otra creación de variable dentro de la función "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else{
                        RESULT = "error_semantico";
                    } 
                :} ;

arregloValores ::=      arregloValor:tipoValor 
                        {: elementosArray.add(tipoValor.toString()); :}
                    |   arregloValor:tipoValor COMA arregloValores
                        {: elementosArray.add(tipoValor.toString()); :} ;
                       

arregloValor ::=        CARACTER:car {: RESULT = car.toString()+": "+"char"; :}
                    |   ENTERO:ent  {: RESULT = ent.toString()+": "+"int"; :}
                    |   ID:id 
                    {:  // ++++ Análisis semántico ++++ 
                        String tipoId = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id"); 
                        if(tipoId != null){
                            RESULT = id.toString()+": "+tipoId; 
                        }
                        else if(tipoId == null && fatherCurrentHash != null){
                            String tipoId2 = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id");
                            if(tipoId2 != null){
                                RESULT = id.toString()+": "+tipoId2; 
                            }
                            else{
                                // Manejo error semántico
                                manejoError("El id: "+id+" no existe o no ha sido creado", "semántico");
                                RESULT = id.toString()+": error_semantico";
                            }
                        }
                        else{
                            // Manejo error semántico
                            manejoError("El id: "+id+" no existe o no ha sido creado", "semántico");
                            RESULT = id.toString()+": error_semantico";
                        }
                    :}  ;

cantidadArreglo ::=     ENTERO:e
                   {:  String entero = e.toString();
                       int ent = Integer.parseInt(entero);
                       // ++++ Análisis semántico ++++ 
                       if(ent >= 0){
                            RESULT = e.toString()+"::int"; 
                        }
                        else{
                            manejoError("El número entero asignado a la cantidad del arreglo es negativo", "semántico");
                            RESULT = "error_semantico";
                        }
                    :}

                    |   ID:id
                    {:  // ++++ Análisis semántico ++++
                        String tipoId = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id"); 
                        if(tipoId != null){
                            RESULT = id.toString()+"::id"; 
                        }
                        else if(tipoId == null && fatherCurrentHash != null){
                            String tipoId2 = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id");
                            if(tipoId2 != null){
                                RESULT = id.toString()+"::id"; 
                            }
                            else{
                                //Manejo de error semántico
                                manejoError("El id: "+id+" asignado a la cantidad del arreglo no existe o no ha sido creado", "semántico");
                                RESULT = "error_semantico";
                            }
                        }
                        else{
                            //Manejo de error semántico
                            manejoError("El id: "+id+" asignado a la cantidad del arreglo no existe o no ha sido creado", "semántico");
                            RESULT = "error_semantico";
                        }
                    :}  ;

// ver que hacer cuando el array tiene una cantidad de tipo ID*****************************************
// me da error ******* esta raro este código, arreglar con lo de primero revisar la tabla padre 
asignaElementoArreglo ::=   expArreglo:exp EQUIV operacionAritmetica:op 
                            {:  if(!exp.equals("error_semantico") && !op.equals("error_semantico")){
                                    String[] partes = exp.toString().split("::");
                                    String[] partesOp = op.toString().split("::");
                                    if(fatherCurrentHash != null){
                                        Boolean exists = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes[0].toString(), "id") != null;
                                        Boolean InPadre = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes[0].toString(), "id") == null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes[0].toString(), "id") != null ;
                                        Boolean InCurrent = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes[0].toString(), "id") != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes[0].toString(), "id") == null ;
                                        if(exists){
                                            if(partes[2].toString().equals("int")){
                                                // ++++ Análisis semántico ++++
                                                String tipoArr = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes[0].toString(), "id");
                                                int limiteInferior = 0;
                                                int limiteSuperior = Integer.parseInt(buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes[0].toString(), "tamañoArray"));
                                                int pos = Integer.parseInt(partes[1].toString());
                                                if(pos >= limiteInferior && pos < limiteSuperior){
                                                    if(tipoArr.equals(partesOp[0].toString())){
                                                        // ++++ Código 3D ++++
                                                        codIn3D.append("\n"+partes[0]+"["+partes[1].toString()+"]"+" = "+partesOp[1]);
                                                        //RESULT = ;  /// +++++++++++++++++++++++++++++++ No sé si se ocupa el RESULT
                                                    }
                                                    else{
                                                        //Manejo de error semántico
                                                        manejoError("El valor asignado no coincide con el tipo de dato del array: "+partes[0].toString(), "semántico");
                                                        RESULT = "error_semantico";
                                                    }
                                                }
                                                else{
                                                    //Manejo de error semántico
                                                    manejoError("La posición : ["+partes[1]+"] está fuera del límite del tamaño del array", "semántico");
                                                    RESULT = "error_semantico";
                                                }
                                            }
                                            else{
                                                String tipoArr = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes[0].toString(), "id");
                                                if(tipoArr.equals(partesOp[0].toString())){
                                                        // ++++ Código 3D ++++
                                                        codIn3D.append("\n"+partes[0]+"["+partes[1].toString()+"]"+" = "+partesOp[1]);
                                                        //RESULT = ;  /// +++++++++++++++++++++++++++++++ No sé si se ocupa el RESULT
                                                }
                                                else{
                                                    //Manejo de error semántico
                                                    manejoError("El valor asignado no coincide con el tipo de dato del array: "+partes[0].toString(), "semántico");
                                                    RESULT = "error_semantico";
                                                }
                                            }
                                        }
                                        else{
                                            //Manejo de error semántico
                                            manejoError("El Array: "+partes[0].toString()+" no existe o no ha sido creado", "semántico");
                                            RESULT = "error_semantico";
                                        }
                                    }
                                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes[0].toString(), "id") != null){
                                        if(partes[2].toString().equals("int")){
                                            // ++++ Análisis semántico ++++
                                            String tipoArr = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes[0].toString(), "id");
                                            int limiteInferior = 0;
                                            int limiteSuperior = Integer.parseInt(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes[0].toString(), "tamañoArray"));
                                            int pos = Integer.parseInt(partes[1].toString());
                                            if(pos >= limiteInferior && pos < limiteSuperior){
                                                if(tipoArr.equals(partesOp[0].toString())){
                                                    // ++++ Código 3D ++++
                                                    codIn3D.append("\n"+partes[0]+"["+partes[1].toString()+"]"+" = "+partesOp[1]);
                                                    //RESULT = ;  /// +++++++++++++++++++++++++++++++ No sé si se ocupa el RESULT
                                                }
                                                else{
                                                    //Manejo de error semántico
                                                    manejoError("El valor asignado no coincide con el tipo de dato del array: "+partes[0].toString(), "semántico");
                                                    RESULT = "error_semantico";
                                                }
                                            }
                                            else{
                                                //Manejo de error semántico
                                                manejoError("La posición : ["+partes[1]+"] está fuera del límite del tamaño del array", "semántico");
                                                RESULT = "error_semantico";
                                            }
                                        }
                                        else{
                                            String tipoArr = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes[0].toString(), "id");
                                            if(tipoArr.equals(partesOp[0].toString())){
                                                    // ++++ Código 3D ++++
                                                    codIn3D.append("\n"+partes[0]+"["+partes[1].toString()+"]"+" = "+partesOp[1]);
                                                    //RESULT = ;  /// +++++++++++++++++++++++++++++++ No sé si se ocupa el RESULT
                                            }
                                            else{
                                                //Manejo de error semántico
                                                manejoError("El valor asignado no coincide con el tipo de dato del array: "+partes[0].toString(), "semántico");
                                                RESULT = "error_semantico";
                                            }
                                        }
                                    }
                                    else{
                                        //Manejo de error semántico
                                        manejoError("El array: "+partes[0].toString()+" no existe o no ha sido creado", "semántico");
                                        RESULT = "error_semantico";
                                    }
                                }
                                else{
                                    RESULT = "error_semantico";
                                 }
                            :} ;
 
expArreglo  ::=     ID:id LPARENT_CUAD cantidadArreglo:cant RPARENT_CUAD 
                    {:  if(!cant.equals("error_semantico")){
                            RESULT = id.toString()+"::"+cant.toString();
                        }
                        else{
                            RESULT = "error_semantico";
                        }
                    :} ;
                       
