package src;
import java_cup.runtime.*;

// Aquí va la gramática BNF que hicimos solo que se pone con ::= en vez de la flecha 
// También se declaran los terminales y los no terminales por medio de los símbolos y las producciones

parser code {:
    Lexer lex;

    @SuppressWarnings("deprecation")
    public parser(Lexer lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
:}

//init with {: :}; // define como inicializar el parser
scan with {: return lex.next_token(); :}; // define como conectarse con el scanner


////// Terminales ///////

terminal INT, CHAR, STRING, FLOAT, BOOLEAN;
terminal ENTERO, DECIMAL, ENTERO_POSITIVO;
//terminal TRUE, FALSE;
terminal IF, ELIF, ELSE, DO, WHILE, FOR;
terminal BREAK, RETURN, MAIN;
terminal EQUIV, DEQUIV, PLUS, MINUS, TIMES, DIV, POWER, MODULE, MINUS_UN, PLUS_UN;
terminal MAYOR_QUE, MAYOR_IGUAL, MENOR_QUE, MENOR_IGUAL;
terminal DIF, OR, AND, NOT;
terminal LPARENT, RPARENT, LPARENT_CUAD, RPARENT_CUAD, INIBLOQUE, FINBLOQUE;
terminal FINEXP, COMA;
terminal PRINT_INT, PRINT_FLOAT, PRINT_STRING, READ_INT, READ_FLOAT;


//non terminal nuevoLenguaje, tipoVar;
////// NO Terminales ///////  
non terminal nuevoLenguaje, funciones, tipoVar, creaVar, funcion, funcionMain, tipoRet, parametros, parametro, sentencias, sentencia;
non terminal bloque, asignacion, operaciones, operacionesAritmeticas, operacionesLogicas, control;
non terminal operacionesRelacionales, operacionUnaria, operandoAr, operandoLog, opAritmetico, opLogico;
non terminal opTipoUnario, operadorRel, negacion, obtEleArreglo, llamaFunc, datosSimples ;
non terminal asigArreglo, elementosArreglo, input, tamArreglo, tipoArreglo, arregloConTam, parteIzAsig, parteDAsig, arregloSinTam; 
non terminal eleNumEnt, eleChar, comentarios, break, output, condicional;
non terminal ciclo, condIf, condElif, condElse, doWhile, for, leeInt, leeFloat, escribeInt, escribeFloat, escribeString; 
non terminal LETRA, ID, return1, CADENA; 

//non terminal nuevoLenguaje, funciones, tipoVar, creaVar, arregloConTam, parteIzAsig;
//non terminal nuevoLenguaje, funciones, tipoVar, creaVar, arregloConTam, parteIzAsig;
//non terminal nuevoLenguaje, funciones, tipoVar, creaVar, arregloConTam, parteIzAsig;

////// precedencia ///////

precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left POWER, MODULE;

////// producción de inicio ///////

start with nuevoLenguaje;

////// producciones de la gramática ///////

nuevoLenguaje ::= funciones; 

// creación de variables 
tipoVar ::=   INT   
            | FLOAT  
            | CHAR   
            | STRING  
            | BOOLEAN ;


creaVar ::= tipoVar ID FINEXP {:System.out.println("Encontró creaVar"); :}
            | arregloConTam FINEXP ; 

// asignación de variables 
parteIzAsig ::= tipoVar ID 
                | ID 
                | obtEleArreglo 
                | arregloConTam 
                | arregloSinTam ;

parteDAsig ::= datosSimples 
               | ID 
               | operacionesAritmeticas 
               | obtEleArreglo 
               | llamaFunc 
               | asigArreglo 
               | input ;

//asignaión             
asignacion ::= parteIzAsig EQUIV parteDAsig FINEXP ;

////// operaciones ///////

// Operaciones aritmeticas
operandoAr ::= ENTERO 
               | DECIMAL 
               | ID 
               | obtEleArreglo ;

opTipoUnario ::= ID 
                 | obtEleArreglo ;

opAritmetico ::= PLUS 
                 | MINUS 
                 | TIMES 
                 | DIV 
                 | MODULE 
                 | POWER ;


operacionesAritmeticas ::= operandoAr ;
operacionesAritmeticas ::= operacionUnaria ; 
operacionesAritmeticas ::= LPARENT operacionesAritmeticas RPARENT ;
operacionesAritmeticas ::= MINUS operacionesAritmeticas ;
operacionesAritmeticas ::= operacionesAritmeticas opAritmetico operacionesAritmeticas ;
operacionUnaria ::= PLUS_UN opTipoUnario ;
operacionUnaria ::= MINUS_UN opTipoUnario ;

// Operaciones relacionales
operadorRel ::= MAYOR_QUE 
                | MAYOR_IGUAL 
                | MENOR_QUE 
                | MENOR_IGUAL 
                | DEQUIV 
                | DIF ;

operacionesRelacionales ::= operacionesAritmeticas operadorRel operacionesAritmeticas ;

// Operaciones logicas
operandoLog ::= ENTERO 
                | DECIMAL 
                | BOOLEAN 
                | ID 
                | obtEleArreglo ;

opLogico ::= AND 
             | OR ;

negacion ::= NOT ;

operacionesLogicas ::= operandoLog ;
operacionesLogicas ::= operacionesRelacionales ;
operacionesLogicas ::= LPARENT operacionesLogicas RPARENT ;
operacionesLogicas ::= negacion operacionesLogicas ;
operacionesLogicas ::= operacionesLogicas opLogico operacionesLogicas ;
operacionesLogicas ::= operacionesLogicas operadorRel operacionesLogicas ;

operaciones ::= operacionesAritmeticas 
                | operacionesLogicas 
                | operacionesRelacionales ;

////// arreglos estáticos /////// 

tipoArreglo ::= INT | CHAR ;
tamArreglo ::= ENTERO_POSITIVO ; 
arregloConTam ::= tipoArreglo ID LPARENT_CUAD tamArreglo RPARENT_CUAD ;
arregloSinTam ::= tipoArreglo ID LPARENT_CUAD RPARENT_CUAD ;  
eleNumEnt ::= ENTERO COMA eleNumEnt | ENTERO ;
eleChar ::= LETRA COMA eleChar | LETRA ;
elementosArreglo ::= eleNumEnt | eleChar ;
asigArreglo ::= INIBLOQUE elementosArreglo FINBLOQUE FINEXP ;
obtEleArreglo ::= ID LPARENT_CUAD tamArreglo RPARENT_CUAD ;

////// funciones ///////

// Funcion Main
funcionMain ::= INT MAIN LPARENT RPARENT bloque ;

funciones ::= funciones funcion 
              | funcion ;

funcion ::= funcionMain 
            | tipoRet ID parametros bloque FINEXP ;

// Retornos de funciones
tipoRet ::= INT 
            | FLOAT 
            | BOOLEAN ;	

// Parametros de funciones
parametro ::= tipoVar ID 
              | arregloConTam 
              | arregloSinTam ;

parametros ::= LPARENT parametro RPARENT 
               | LPARENT parametro COMA parametros RPARENT 
               | LPARENT RPARENT ;

// Bloques de funciones
bloque ::= INIBLOQUE sentencias FINBLOQUE ;

// Sentencias
sentencias ::= sentencia 
               | sentencia sentencias ;

sentencia ::= creaVar 
              | asignacion 
              | operaciones 
              | llamaFunc 
              | control 
              | funcion 
              | return1 
              | comentarios 
              | break 
              | output ;

// Llamada a funciones
llamaFunc ::= ID parametros FINEXP ;

// Return de funciones
return1 ::= RETURN ID FINEXP ;
return1 ::= RETURN ENTERO  FINEXP 
            | RETURN DECIMAL FINEXP 
            | RETURN  CHAR FINEXP 
            | RETURN CADENA FINEXP 
            | RETURN BOOLEAN FINEXP ;

return1 ::= RETURN llamaFunc ;
return1 ::= RETURN operaciones FINEXP ;

// Break
break ::= BREAK FINEXP ;

// Estructuras de control 
control ::= condicional 
            | ciclo ;

// Condicionales

condicional ::= condIf 
                | condElif 
                | condElse ;  // ver si así funciona *************

condIf ::= IF LPARENT operacionesLogicas RPARENT bloque ;
condElse ::= ELSE bloque ;
condElif ::= ELIF LPARENT operacionesLogicas RPARENT bloque ;

// Ciclos
doWhile ::= DO bloque WHILE LPARENT operacionesLogicas RPARENT FINEXP ;
for ::= FOR LPARENT asignacion FINEXP operacionesLogicas FINEXP asignacion RPARENT bloque ; 
ciclo ::= doWhile 
          | FOR ;


////// input y output ///////

// Input

input ::= leeInt 
          | leeFloat ;
leeInt ::= READ_INT LPARENT RPARENT FINEXP ;
leeFloat ::= READ_FLOAT LPARENT RPARENT FINEXP ;

// Output

output ::= escribeInt 
           | escribeFloat 
           | escribeString ;

escribeInt ::= PRINT_INT LPARENT ID RPARENT FINEXP 
               | PRINT_INT LPARENT ENTERO RPARENT FINEXP ;

escribeFloat ::= PRINT_FLOAT LPARENT ID RPARENT FINEXP 
                 | PRINT_FLOAT LPARENT DECIMAL RPARENT FINEXP ;

escribeString ::= PRINT_STRING LPARENT ID RPARENT FINEXP 
                  | PRINT_STRING LPARENT CADENA RPARENT FINEXP ;
                  
