package src;
import java_cup.runtime.*;

// Aquí va la gramática BNF que hicimos solo que se pone con ::= en vez de la flecha 
// También se declaran los terminales y los no terminales por medio de los símbolos y las producciones

parser code {:
    Lexer lex;

    @SuppressWarnings("deprecation")
    public parser(Lexer lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
:}



//init with {: :}; // define como inicializar el parser
scan with {: return lex.next_token(); :}; // define como conectarse con el scanner


////// Terminales ///////

terminal INT, CHAR, STRING, FLOAT, ID, CADENA;
terminal ENTERO, DECIMAL, ENTERO_POSITIVO;
terminal BOOLEAN, TRUE, FALSE;
terminal IF, ELIF, ELSE, DO, WHILE, FOR;
terminal BREAK, RETURN, MAIN;
terminal EQUIV, DEQUIV, PLUS, MINUS, TIMES, DIV, POWER, MODULE, MINUS_UN, PLUS_UN;
terminal MAYOR_QUE, MAYOR_IGUAL, MENOR_QUE, MENOR_IGUAL;
terminal DIF, OR, AND, NOT;
terminal LPARENT, RPARENT, LPARENT_CUAD, RPARENT_CUAD, INIBLOQUE, FINBLOQUE;
terminal FINEXP, COMA, PUNTO;
terminal PRINT_INT, PRINT_FLOAT, PRINT_STRING, READ_INT, READ_FLOAT;


non terminal nuevoLenguaje, tipoVar;
////// NO Terminales ///////  Falta gregar todas las demás *************************
/* non terminal nuevoLenguaje, funciones, tipoVar, creaVar, funcion, funcionMain, tipoRet, parametros, parametro, sentencias, sentencia;
non terminal bloque, asignacion, operaciones, operacionesAritmeticas, operacionesLogicas, control;
non terminal operacionesRelacionales, operacionUnaria, operandoAr, operandoLog, opAritmetico, opLogico;
non terminal opTipoUnario, operadorRel, negacion, obtEleArreglo, llamaFunc, datosSimples, asigArregloConTam;
non terminal asigArregloSinTam, input, tamArreglo, tipoArreglo, arregloConTam, parteIzAsig, parteDAsig, arregloSinTam; 
non terminal eleNumEnt, eleCharS, eleCharP, comentarios, break, output, condicional;
non terminal ciclo, condIf, condElif, condElse, doWhile, for, leeInt, leeFloat, escribeInt, escribeFloat, escribeString; 
non terminal letra, return1, cadena; */ // Algo raro aca
//non terminal nuevoLenguaje, funciones, tipoVar, creaVar, arregloConTam, parteIzAsig;
//non terminal nuevoLenguaje, funciones, tipoVar, creaVar, arregloConTam, parteIzAsig;
//non terminal nuevoLenguaje, funciones, tipoVar, creaVar, arregloConTam, parteIzAsig;
////// precedencia ///////

precedence left PLUS, MINUS;
precedence left TIMES, DIV;

////// producción de inicio ///////

start with nuevoLenguaje;

////// producciones de la gramática ///////

nuevoLenguaje ::= tipoVar; 

// creación de variables 
tipoVar ::=   INT   
            | FLOAT  
            | CHAR   
            | STRING  
            | BOOLEAN ;

/* 
creaVar ::= (tipoVar:tip ID:id {:System.out.println(tip); System.out.println(id);:}
            | arregloConTam) 
            FINEXP ; 

// asignación de variables 
parteIzAsig ::= tipoVar ID 
                | ID 
                | obtEleArreglo 
                | arregloConTam 
                | arregloSinTam ;

parteDAsig ::= datosSimples 
               | ID 
               | operacionesAritmeticas 
               | obtEleArreglo 
               | llamaFunc 
               | asigArregloConTam 
               | asigArregloSinTam 
               | input ;

//asignaión             
asignacion ::= parteIzAsig EQUIV parteDAsig FINEXP ;

////// operaciones ///////

// Operaciones aritmeticas
operandoAr ::= ENTERO 
               | DECIMAL 
               | ID 
               | obtEleArreglo ;

opTipoUnario ::= ID 
                 | obtEleArreglo ;

opAritmetico ::= PLUS 
                 | MINUS 
                 | TIMES 
                 | DIV 
                 | MODULE 
                 | POWER ;


operacionesAritmeticas ::= operandoAr ;
operacionesAritmeticas ::= operacionUnaria ; 
operacionesAritmeticas ::= LPARENT operacionesAritmeticas RPARENT ;
operacionesAritmeticas ::= MINUS operacionesAritmeticas ;
operacionesAritmeticas ::= operacionesAritmeticas opAritmetico operacionesAritmeticas ;
operacionUnaria ::= PLUS_UN opTipoUnario ;
operacionUnaria ::= MINUS_UN opTipoUnario ;

// Operaciones relacionales
operadorRel ::= MAYOR_QUE 
                | MAYOR_IGUAL 
                | MENOR_QUE 
                | MENOR_IGUAL 
                | DEQUIV 
                | DIF ;

operacionesRelacionales ::= operacionesAritmeticas operadorRel operacionesAritmeticas ;

// Operaciones logicas
operandoLog ::= ENTERO 
                | DECIMAL 
                | BOOLEAN 
                | ID 
                | obtEleArreglo ;

opLogico ::= AND 
             | OR ;

negacion ::= NOT ;

operacionesLogicas ::= operandoLog ;
operacionesLogicas ::= operacionesRelacionales ;
operacionesLogicas ::= LPARENT operacionesLogicas RPARENT ;
operacionesLogicas ::= negacion operacionesLogicas ;
operacionesLogicas ::= operacionesLogicas opLogico operacionesLogicas ;
operacionesLogicas ::= operacionesLogicas operadorRel operacionesLogicas ;

operaciones ::= operacionesAritmeticas 
                | operacionesLogicas 
                | operacionesRelacionales ;

////// arreglos estáticos ///////  falta arreglar **********************

tipoArreglo ::= INT | CHAR;

tamArreglo ::= ENTERO_POSITIVO; 
arregloConTam ::= tipoArreglo ID LPARENT_CUAD tamArreglo RPARENT_CUAD;
arregloSinTam ::= tipoArreglo ID LPARENT_CUAD RPARENT_CUAD;
eleNumEnt ::= ENTERO COMA eleNumEnt | ENTERO;
//eleCharP ::= . ;
eleCharS ::= letra COMA eleCharS | letra ;
asigArregloConTam ::= INIBLOQUE (eleNumEnt{tamArreglo} | '\"'eleCharP{tamArreglo}'\"' | eleCharS{tamArreglo}) FINBLOQUE FINEXP;
//asigArregloSinTam ::= INIBLOQUE (eleNumEnt* | eleCharS*) FINBLOQUE FINEXP;
obtEleArreglo ::= ID LPARENT_CUAD tamArreglo RPARENT_CUAD;

////// funciones ///////

// Funcion Main
funcionMain ::= INT MAIN LPARENT RPARENT bloque ;

funciones ::= funciones funcion 
              | funcion ;

funcion ::= funcionMain 
            | tipoRet ID parametros bloque FINEXP ;

// Retornos de funciones
tipoRet ::= INT 
            | FLOAT 
            | BOOLEAN ;	

// Parametros de funciones
parametro ::= tipoVar ID 
              | arregloConTam 
              | arregloSinTam ;

parametros ::= LPARENT (parametro | parametro COMA parametros) RPARENT 
               | LPARENT RPARENT ;

// Bloques de funciones
bloque ::= INIBLOQUE sentencias FINBLOQUE ;

// Sentencias
sentencias ::= sentencia 
               | sentencia sentencias ;

sentencia ::= creaVar 
              | asignacion 
              | operaciones 
              | llamaFunc 
              | control 
              | funcion 
              | return1 
              | comentarios 
              | break 
              | output ;

// Llamada a funciones
llamaFunc ::= ID parametros FINEXP ;

// Return de funciones
return1 ::= RETURN ID FINEXP ;
return1 ::= RETURN (ENTERO 
                   | DECIMAL 
                   | CHAR 
                   | CADENA 
                   | BOOLEAN) 
                   FINEXP ;

return1 ::= RETURN llamaFunc ;
return1 ::= RETURN operaciones FINEXP ;

// Break
break ::= BREAK FINEXP ;

// Estructuras de control 
control ::= condicional 
            | ciclo ;

// Condicionales

condicional ::= condIf 
                | condElif 
                | condElse ;  // ver si así funciona *************

condIf ::= IF LPARENT operacionesLogicas RPARENT bloque ;
condElse ::= ELSE bloque ;
condElif ::= ELIF LPARENT operacionesLogicas RPARENT bloque ;

// Ciclos
doWhile ::= DO bloque WHILE LPARENT operacionesLogicas RPARENT FINEXP ;
for ::= FOR LPARENT asignacion FINEXP operacionesLogicas FINEXP asignacion RPARENT bloque ; 
ciclo ::= doWhile 
          | FOR ;


////// input y output ///////

// Input

input ::= leeInt 
          | leeFloat ;
leeInt ::= READ_INT LPARENT RPARENT FINEXP ;
leeFloat ::= READ_FLOAT LPARENT RPARENT FINEXP ;

// Output

output ::= escribeInt 
           | escribeFloat 
           | escribeString ;

escribeInt ::= PRINT_INT LPARENT (ID | ENTERO) RPARENT FINEXP ;
escribeFloat ::= PRINT_FLOAT LPARENT (ID | DECIMAL) RPARENT FINEXP ;
escribeString ::= PRINT_STRING LPARENT (ID | cadena) RPARENT FINEXP ;

 */